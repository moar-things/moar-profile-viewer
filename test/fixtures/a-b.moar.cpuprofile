{
  "meta": {
    "date": "2017-09-07T22:58:47.517Z",
    "title": "node",
    "nodeVersion": "8.1.4",
    "arch": "x64",
    "platform": "darwin",
    "pid": 2471,
    "execPath": "/usr/local/bin/node",
    "mainModule": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
    "moarVersion": "1.8.1"
  },
  "nodes": [
    {
      "id": 1,
      "callFrame": {
        "functionName": "(root)",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        2,
        37,
        124
      ]
    },
    {
      "id": 2,
      "callFrame": {
        "functionName": "listOnTimeout",
        "scriptId": "29",
        "url": "timers.js",
        "lineNumber": 223,
        "columnNumber": 22
      },
      "hitCount": 0,
      "children": [
        3
      ]
    },
    {
      "id": 3,
      "callFrame": {
        "functionName": "tryOnTimeout",
        "scriptId": "29",
        "url": "timers.js",
        "lineNumber": 314,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        4
      ]
    },
    {
      "id": 4,
      "callFrame": {
        "functionName": "ontimeout",
        "scriptId": "29",
        "url": "timers.js",
        "lineNumber": 481,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        5
      ]
    },
    {
      "id": 5,
      "callFrame": {
        "functionName": "run",
        "scriptId": "56",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
        "lineNumber": 7,
        "columnNumber": 13
      },
      "hitCount": 0,
      "children": [
        6
      ]
    },
    {
      "id": 6,
      "callFrame": {
        "functionName": "a",
        "scriptId": "56",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
        "lineNumber": 11,
        "columnNumber": 11
      },
      "hitCount": 0,
      "children": [
        7,
        80,
        163
      ]
    },
    {
      "id": 7,
      "callFrame": {
        "functionName": "b",
        "scriptId": "56",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
        "lineNumber": 18,
        "columnNumber": 11
      },
      "hitCount": 0,
      "children": [
        8,
        199
      ]
    },
    {
      "id": 8,
      "callFrame": {
        "functionName": "wait",
        "scriptId": "56",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
        "lineNumber": 23,
        "columnNumber": 14
      },
      "hitCount": 1,
      "children": [
        9,
        61,
        211
      ],
      "positionTicks": [
        {
          "line": 20,
          "ticks": 1
        }
      ]
    },
    {
      "id": 9,
      "callFrame": {
        "functionName": "",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 329,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        10,
        23,
        69,
        222,
        232,
        234,
        244
      ]
    },
    {
      "id": 10,
      "callFrame": {
        "functionName": "_ls",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 42,
        "columnNumber": 12
      },
      "hitCount": 1,
      "children": [
        11
      ],
      "deoptReason": "Assignment to parameter in arguments object",
      "positionTicks": [
        {
          "line": 58,
          "ticks": 1
        }
      ]
    },
    {
      "id": 11,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        12
      ]
    },
    {
      "id": 12,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        13
      ]
    },
    {
      "id": 13,
      "callFrame": {
        "functionName": "",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 72,
        "columnNumber": 25
      },
      "hitCount": 1,
      "children": [
        14,
        16,
        21,
        74
      ],
      "positionTicks": [
        {
          "line": 77,
          "ticks": 1
        }
      ]
    },
    {
      "id": 14,
      "callFrame": {
        "functionName": "fs.readdirSync",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 904,
        "columnNumber": 25
      },
      "hitCount": 16,
      "children": [
        15,
        36
      ],
      "positionTicks": [
        {
          "line": 65,
          "ticks": 1
        },
        {
          "line": 906,
          "ticks": 15
        }
      ]
    },
    {
      "id": 15,
      "callFrame": {
        "functionName": "pushValueToArray",
        "scriptId": "22",
        "url": "bootstrap_node.js",
        "lineNumber": 208,
        "columnNumber": 29
      },
      "hitCount": 0
    },
    {
      "id": 36,
      "callFrame": {
        "functionName": "readdir",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 196,
      "children": [
        264
      ],
      "positionTicks": [
        {
          "line": 906,
          "ticks": 196
        }
      ]
    },
    {
      "id": 264,
      "callFrame": {
        "functionName": "pushValueToArray",
        "scriptId": "22",
        "url": "bootstrap_node.js",
        "lineNumber": 208,
        "columnNumber": 29
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 210,
          "ticks": 1
        }
      ]
    },
    {
      "id": 16,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        17
      ]
    },
    {
      "id": 17,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 7,
      "children": [
        18
      ],
      "positionTicks": [
        {
          "line": 776,
          "ticks": 7
        }
      ]
    },
    {
      "id": 18,
      "callFrame": {
        "functionName": "",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 100,
        "columnNumber": 43
      },
      "hitCount": 14,
      "children": [
        19,
        45
      ],
      "positionTicks": [
        {
          "line": 102,
          "ticks": 10
        },
        {
          "line": 103,
          "ticks": 4
        }
      ]
    },
    {
      "id": 19,
      "callFrame": {
        "functionName": "join",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 1225,
        "columnNumber": 21
      },
      "hitCount": 16,
      "children": [
        20
      ],
      "positionTicks": [
        {
          "line": 1232,
          "ticks": 1
        },
        {
          "line": 1233,
          "ticks": 1
        },
        {
          "line": 1237,
          "ticks": 3
        },
        {
          "line": 1240,
          "ticks": 1
        },
        {
          "line": 1227,
          "ticks": 7
        },
        {
          "line": 28,
          "ticks": 1
        },
        {
          "line": 1230,
          "ticks": 2
        }
      ]
    },
    {
      "id": 20,
      "callFrame": {
        "functionName": "normalize",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 1196,
        "columnNumber": 31
      },
      "hitCount": 36,
      "children": [
        38
      ],
      "positionTicks": [
        {
          "line": 1209,
          "ticks": 4
        },
        {
          "line": 1203,
          "ticks": 30
        },
        {
          "line": 1198,
          "ticks": 1
        },
        {
          "line": 1207,
          "ticks": 1
        }
      ]
    },
    {
      "id": 38,
      "callFrame": {
        "functionName": "normalizeStringPosix",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 98,
        "columnNumber": 29
      },
      "hitCount": 61,
      "children": [
        39
      ],
      "positionTicks": [
        {
          "line": 148,
          "ticks": 7
        },
        {
          "line": 151,
          "ticks": 3
        },
        {
          "line": 104,
          "ticks": 18
        },
        {
          "line": 105,
          "ticks": 18
        },
        {
          "line": 106,
          "ticks": 5
        },
        {
          "line": 107,
          "ticks": 5
        },
        {
          "line": 143,
          "ticks": 5
        }
      ]
    },
    {
      "id": 39,
      "callFrame": {
        "functionName": "slice",
        "scriptId": "7",
        "url": "native string.js",
        "lineNumber": 40,
        "columnNumber": 20
      },
      "hitCount": 24,
      "positionTicks": [
        {
          "line": 41,
          "ticks": 24
        }
      ]
    },
    {
      "id": 45,
      "callFrame": {
        "functionName": "pushFile",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 59,
        "columnNumber": 19
      },
      "hitCount": 7,
      "positionTicks": [
        {
          "line": 61,
          "ticks": 6
        },
        {
          "line": 62,
          "ticks": 1
        }
      ]
    },
    {
      "id": 21,
      "callFrame": {
        "functionName": "fs.lstatSync",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 942,
        "columnNumber": 23
      },
      "hitCount": 2,
      "children": [
        22,
        76,
        218
      ],
      "positionTicks": [
        {
          "line": 944,
          "ticks": 1
        },
        {
          "line": 947,
          "ticks": 1
        }
      ]
    },
    {
      "id": 22,
      "callFrame": {
        "functionName": "lstat",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 24,
      "positionTicks": [
        {
          "line": 947,
          "ticks": 24
        }
      ]
    },
    {
      "id": 76,
      "callFrame": {
        "functionName": "statsFromValues",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 2,
      "children": [
        77
      ],
      "positionTicks": [
        {
          "line": 1439,
          "ticks": 2
        }
      ]
    },
    {
      "id": 77,
      "callFrame": {
        "functionName": "Stats",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 173,
        "columnNumber": 14
      },
      "hitCount": 10,
      "positionTicks": [
        {
          "line": 203,
          "ticks": 7
        },
        {
          "line": 204,
          "ticks": 2
        },
        {
          "line": 205,
          "ticks": 1
        }
      ]
    },
    {
      "id": 218,
      "callFrame": {
        "functionName": "getPathFromURL",
        "scriptId": "38",
        "url": "fs.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 1433,
          "ticks": 1
        }
      ]
    },
    {
      "id": 74,
      "callFrame": {
        "functionName": "Stats.isDirectory",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 213,
        "columnNumber": 38
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 211,
          "ticks": 1
        }
      ]
    },
    {
      "id": 23,
      "callFrame": {
        "functionName": "expand",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 250,
        "columnNumber": 15
      },
      "hitCount": 0,
      "children": [
        24
      ]
    },
    {
      "id": 24,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        25
      ]
    },
    {
      "id": 25,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        26
      ]
    },
    {
      "id": 26,
      "callFrame": {
        "functionName": "",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 255,
        "columnNumber": 24
      },
      "hitCount": 0,
      "children": [
        27
      ]
    },
    {
      "id": 27,
      "callFrame": {
        "functionName": "globSync",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 20,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        28
      ]
    },
    {
      "id": 28,
      "callFrame": {
        "functionName": "GlobSync",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 28,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        29,
        40,
        50
      ]
    },
    {
      "id": 29,
      "callFrame": {
        "functionName": "GlobSync._process",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 76,
        "columnNumber": 39
      },
      "hitCount": 0,
      "children": [
        30,
        236
      ]
    },
    {
      "id": 30,
      "callFrame": {
        "functionName": "GlobSync._processReaddir",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 135,
        "columnNumber": 46
      },
      "hitCount": 6,
      "children": [
        31,
        46,
        230
      ],
      "positionTicks": [
        {
          "line": 151,
          "ticks": 1
        },
        {
          "line": 161,
          "ticks": 1
        },
        {
          "line": 137,
          "ticks": 1
        },
        {
          "line": 213,
          "ticks": 1
        },
        {
          "line": 485,
          "ticks": 1
        },
        {
          "line": 191,
          "ticks": 1
        }
      ]
    },
    {
      "id": 31,
      "callFrame": {
        "functionName": "GlobSync._emitMatch",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 7,
      "children": [
        32,
        209
      ],
      "positionTicks": [
        {
          "line": 191,
          "ticks": 7
        }
      ]
    },
    {
      "id": 32,
      "callFrame": {
        "functionName": "GlobSync._makeAbs",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        33
      ]
    },
    {
      "id": 33,
      "callFrame": {
        "functionName": "makeAbs",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        34
      ]
    },
    {
      "id": 34,
      "callFrame": {
        "functionName": "resolve",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 1151,
        "columnNumber": 27
      },
      "hitCount": 4,
      "children": [
        35,
        78
      ],
      "positionTicks": [
        {
          "line": 1162,
          "ticks": 3
        },
        {
          "line": 1159,
          "ticks": 1
        }
      ]
    },
    {
      "id": 35,
      "callFrame": {
        "functionName": "cwd",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 57,
      "positionTicks": [
        {
          "line": 1162,
          "ticks": 57
        }
      ]
    },
    {
      "id": 78,
      "callFrame": {
        "functionName": "normalizeStringPosix",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 98,
        "columnNumber": 29
      },
      "hitCount": 4,
      "children": [
        224
      ],
      "positionTicks": [
        {
          "line": 104,
          "ticks": 1
        },
        {
          "line": 105,
          "ticks": 1
        },
        {
          "line": 143,
          "ticks": 2
        }
      ]
    },
    {
      "id": 224,
      "callFrame": {
        "functionName": "slice",
        "scriptId": "7",
        "url": "native string.js",
        "lineNumber": 40,
        "columnNumber": 20
      },
      "hitCount": 2,
      "positionTicks": [
        {
          "line": 41,
          "ticks": 2
        }
      ]
    },
    {
      "id": 209,
      "callFrame": {
        "functionName": "isIgnored",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 223,
        "columnNumber": 19
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 228,
          "ticks": 1
        }
      ]
    },
    {
      "id": 46,
      "callFrame": {
        "functionName": "GlobSync._readdir",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 271,
        "columnNumber": 39
      },
      "hitCount": 0,
      "children": [
        47,
        48,
        265
      ]
    },
    {
      "id": 47,
      "callFrame": {
        "functionName": "GlobSync._readdirEntries",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 294,
        "columnNumber": 46
      },
      "hitCount": 7,
      "positionTicks": [
        {
          "line": 300,
          "ticks": 1
        },
        {
          "line": 302,
          "ticks": 6
        }
      ]
    },
    {
      "id": 48,
      "callFrame": {
        "functionName": "fs.readdirSync",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 904,
        "columnNumber": 25
      },
      "hitCount": 0,
      "children": [
        49
      ]
    },
    {
      "id": 49,
      "callFrame": {
        "functionName": "readdir",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 18,
      "positionTicks": [
        {
          "line": 906,
          "ticks": 18
        }
      ]
    },
    {
      "id": 265,
      "callFrame": {
        "functionName": "ownProp",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 10,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        266
      ]
    },
    {
      "id": 266,
      "callFrame": {
        "functionName": "hasOwnProperty",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1
    },
    {
      "id": 230,
      "callFrame": {
        "functionName": "match",
        "scriptId": "7",
        "url": "native string.js",
        "lineNumber": 16,
        "columnNumber": 22
      },
      "hitCount": 0,
      "children": [
        231
      ]
    },
    {
      "id": 231,
      "callFrame": {
        "functionName": "[Symbol.match]",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 2
    },
    {
      "id": 236,
      "callFrame": {
        "functionName": "GlobSync._makeAbs",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        237
      ]
    },
    {
      "id": 237,
      "callFrame": {
        "functionName": "makeAbs",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        238
      ]
    },
    {
      "id": 238,
      "callFrame": {
        "functionName": "resolve",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 1151,
        "columnNumber": 27
      },
      "hitCount": 0,
      "children": [
        239
      ]
    },
    {
      "id": 239,
      "callFrame": {
        "functionName": "cwd",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 4,
      "positionTicks": [
        {
          "line": 1162,
          "ticks": 4
        }
      ]
    },
    {
      "id": 40,
      "callFrame": {
        "functionName": "GlobSync._finish",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 52,
        "columnNumber": 38
      },
      "hitCount": 0,
      "children": [
        41
      ]
    },
    {
      "id": 41,
      "callFrame": {
        "functionName": "finish",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 121,
        "columnNumber": 16
      },
      "hitCount": 0,
      "children": [
        42,
        57
      ]
    },
    {
      "id": 42,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        43
      ]
    },
    {
      "id": 43,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        44
      ]
    },
    {
      "id": 44,
      "callFrame": {
        "functionName": "",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 142,
        "columnNumber": 27
      },
      "hitCount": 3,
      "positionTicks": [
        {
          "line": 143,
          "ticks": 3
        }
      ]
    },
    {
      "id": 57,
      "callFrame": {
        "functionName": "sort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 748,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        58
      ]
    },
    {
      "id": 58,
      "callFrame": {
        "functionName": "InnerArraySort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 529,
        "columnNumber": 23
      },
      "hitCount": 0,
      "children": [
        59
      ]
    },
    {
      "id": 59,
      "callFrame": {
        "functionName": "QuickSort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 573,
        "columnNumber": 18
      },
      "hitCount": 2,
      "children": [
        60,
        66,
        79,
        225
      ],
      "positionTicks": [
        {
          "line": 574,
          "ticks": 2
        }
      ]
    },
    {
      "id": 60,
      "callFrame": {
        "functionName": "localeCompare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1228,
        "columnNumber": 38
      },
      "hitCount": 2,
      "children": [
        233,
        246
      ],
      "deoptReason": "Bad value context for arguments value",
      "positionTicks": [
        {
          "line": 1229,
          "ticks": 2
        }
      ]
    },
    {
      "id": 233,
      "callFrame": {
        "functionName": "compare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 654,
        "columnNumber": 16
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 655,
          "ticks": 1
        }
      ]
    },
    {
      "id": 246,
      "callFrame": {
        "functionName": "cachedOrNewService",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1201,
        "columnNumber": 27
      },
      "hitCount": 0,
      "children": [
        247
      ]
    },
    {
      "id": 247,
      "callFrame": {
        "functionName": "checkDateCacheCurrent",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1193,
        "columnNumber": 30
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 1194,
          "ticks": 1
        }
      ]
    },
    {
      "id": 66,
      "callFrame": {
        "functionName": "alphasort",
        "scriptId": "70",
        "url": "native array.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        67
      ]
    },
    {
      "id": 67,
      "callFrame": {
        "functionName": "localeCompare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1228,
        "columnNumber": 38
      },
      "hitCount": 0,
      "children": [
        68
      ],
      "deoptReason": "Bad value context for arguments value"
    },
    {
      "id": 68,
      "callFrame": {
        "functionName": "compare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 654,
        "columnNumber": 16
      },
      "hitCount": 2,
      "positionTicks": [
        {
          "line": 655,
          "ticks": 2
        }
      ]
    },
    {
      "id": 79,
      "callFrame": {
        "functionName": "InsertionSort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 542,
        "columnNumber": 22
      },
      "hitCount": 2,
      "children": [
        219
      ],
      "positionTicks": [
        {
          "line": 543,
          "ticks": 2
        }
      ]
    },
    {
      "id": 219,
      "callFrame": {
        "functionName": "alphasort",
        "scriptId": "70",
        "url": "native array.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        220
      ]
    },
    {
      "id": 220,
      "callFrame": {
        "functionName": "localeCompare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1228,
        "columnNumber": 38
      },
      "hitCount": 0,
      "children": [
        221
      ],
      "deoptReason": "Bad value context for arguments value"
    },
    {
      "id": 221,
      "callFrame": {
        "functionName": "compare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 654,
        "columnNumber": 16
      },
      "hitCount": 6,
      "positionTicks": [
        {
          "line": 655,
          "ticks": 6
        }
      ]
    },
    {
      "id": 225,
      "callFrame": {
        "functionName": "QuickSort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 573,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        226
      ]
    },
    {
      "id": 226,
      "callFrame": {
        "functionName": "InsertionSort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 542,
        "columnNumber": 22
      },
      "hitCount": 0,
      "children": [
        227
      ]
    },
    {
      "id": 227,
      "callFrame": {
        "functionName": "alphasort",
        "scriptId": "70",
        "url": "native array.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        228
      ]
    },
    {
      "id": 228,
      "callFrame": {
        "functionName": "localeCompare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1228,
        "columnNumber": 38
      },
      "hitCount": 0,
      "children": [
        229
      ],
      "deoptReason": "Bad value context for arguments value"
    },
    {
      "id": 229,
      "callFrame": {
        "functionName": "compare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 654,
        "columnNumber": 16
      },
      "hitCount": 3,
      "positionTicks": [
        {
          "line": 655,
          "ticks": 3
        }
      ]
    },
    {
      "id": 50,
      "callFrame": {
        "functionName": "setopts",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 52,
        "columnNumber": 17
      },
      "hitCount": 1,
      "children": [
        51,
        75
      ],
      "positionTicks": [
        {
          "line": 98,
          "ticks": 1
        }
      ]
    },
    {
      "id": 51,
      "callFrame": {
        "functionName": "Minimatch",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        52
      ]
    },
    {
      "id": 52,
      "callFrame": {
        "functionName": "make",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/minimatch/minimatch.js",
        "lineNumber": 141,
        "columnNumber": 14
      },
      "hitCount": 0,
      "children": [
        53,
        210
      ]
    },
    {
      "id": 53,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        54
      ]
    },
    {
      "id": 54,
      "callFrame": {
        "functionName": "",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/minimatch/minimatch.js",
        "lineNumber": 180,
        "columnNumber": 25
      },
      "hitCount": 0,
      "children": [
        55
      ]
    },
    {
      "id": 55,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        56
      ]
    },
    {
      "id": 56,
      "callFrame": {
        "functionName": "parse",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/minimatch/minimatch.js",
        "lineNumber": 270,
        "columnNumber": 15
      },
      "hitCount": 3,
      "positionTicks": [
        {
          "line": 359,
          "ticks": 1
        },
        {
          "line": 271,
          "ticks": 2
        }
      ]
    },
    {
      "id": 210,
      "callFrame": {
        "functionName": "braceExpand",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/minimatch/minimatch.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 160,
          "ticks": 1
        }
      ]
    },
    {
      "id": 75,
      "callFrame": {
        "functionName": "cwd",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 3,
      "positionTicks": [
        {
          "line": 93,
          "ticks": 3
        }
      ]
    },
    {
      "id": 69,
      "callFrame": {
        "functionName": "ShellString",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 150,
        "columnNumber": 20
      },
      "hitCount": 0,
      "children": [
        70
      ]
    },
    {
      "id": 70,
      "callFrame": {
        "functionName": "join",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 287,
        "columnNumber": 18
      },
      "hitCount": 1,
      "children": [
        71
      ],
      "positionTicks": [
        {
          "line": 288,
          "ticks": 1
        }
      ]
    },
    {
      "id": 71,
      "callFrame": {
        "functionName": "InnerArrayJoin",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 274,
        "columnNumber": 23
      },
      "hitCount": 0,
      "children": [
        72
      ]
    },
    {
      "id": 72,
      "callFrame": {
        "functionName": "Join",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 120,
        "columnNumber": 13
      },
      "hitCount": 0,
      "children": [
        73
      ]
    },
    {
      "id": 73,
      "callFrame": {
        "functionName": "DoJoin",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 95,
        "columnNumber": 15
      },
      "hitCount": 15,
      "positionTicks": [
        {
          "line": 96,
          "ticks": 15
        }
      ]
    },
    {
      "id": 222,
      "callFrame": {
        "functionName": "getUserHome",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 174,
        "columnNumber": 20
      },
      "hitCount": 0,
      "children": [
        223
      ]
    },
    {
      "id": 223,
      "callFrame": {
        "functionName": "getHomeDirectory",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 2,
      "positionTicks": [
        {
          "line": 180,
          "ticks": 2
        }
      ]
    },
    {
      "id": 232,
      "callFrame": {
        "functionName": "parseOptions",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 189,
        "columnNumber": 21
      },
      "hitCount": 1,
      "children": [
        241
      ],
      "positionTicks": [
        {
          "line": 192,
          "ticks": 1
        }
      ]
    },
    {
      "id": 241,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        242
      ]
    },
    {
      "id": 242,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        243
      ]
    },
    {
      "id": 243,
      "callFrame": {
        "functionName": "",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 201,
        "columnNumber": 36
      },
      "hitCount": 2,
      "positionTicks": [
        {
          "line": 204,
          "ticks": 2
        }
      ]
    },
    {
      "id": 234,
      "callFrame": {
        "functionName": "reduce",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 915,
        "columnNumber": 20
      },
      "hitCount": 0,
      "children": [
        235
      ]
    },
    {
      "id": 235,
      "callFrame": {
        "functionName": "InnerArrayReduce",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 893,
        "columnNumber": 25
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 894,
          "ticks": 1
        }
      ]
    },
    {
      "id": 244,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        245
      ]
    },
    {
      "id": 245,
      "callFrame": {
        "functionName": "ArraySpeciesCreate",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 22,
        "columnNumber": 27
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 23,
          "ticks": 1
        }
      ]
    },
    {
      "id": 61,
      "callFrame": {
        "functionName": "parseArcFile",
        "scriptId": "110",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1,
      "children": [
        62
      ],
      "positionTicks": [
        {
          "line": 28,
          "ticks": 1
        }
      ]
    },
    {
      "id": 62,
      "callFrame": {
        "functionName": "getSections",
        "scriptId": "112",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_get-sections.js",
        "lineNumber": 0,
        "columnNumber": 99
      },
      "hitCount": 0,
      "children": [
        63
      ]
    },
    {
      "id": 63,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        64
      ]
    },
    {
      "id": 64,
      "callFrame": {
        "functionName": "text.split.filter.map.c",
        "scriptId": "112",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_get-sections.js",
        "lineNumber": 10,
        "columnNumber": 53
      },
      "hitCount": 0,
      "children": [
        65
      ]
    },
    {
      "id": 65,
      "callFrame": {
        "functionName": "split",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 2
    },
    {
      "id": 211,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        212
      ]
    },
    {
      "id": 212,
      "callFrame": {
        "functionName": "visit",
        "scriptId": "113",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_parse-section.js",
        "lineNumber": 0,
        "columnNumber": 93
      },
      "hitCount": 0,
      "children": [
        213
      ]
    },
    {
      "id": 213,
      "callFrame": {
        "functionName": "parseMembers",
        "scriptId": "113",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_parse-section.js",
        "lineNumber": 14,
        "columnNumber": 21
      },
      "hitCount": 1,
      "children": [
        214
      ],
      "positionTicks": [
        {
          "line": 18,
          "ticks": 1
        }
      ]
    },
    {
      "id": 214,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        215
      ]
    },
    {
      "id": 215,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        216
      ]
    },
    {
      "id": 216,
      "callFrame": {
        "functionName": "members.forEach.member",
        "scriptId": "113",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_parse-section.js",
        "lineNumber": 23,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        217,
        240
      ]
    },
    {
      "id": 217,
      "callFrame": {
        "functionName": "test",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1
    },
    {
      "id": 240,
      "callFrame": {
        "functionName": "isNaN",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1
    },
    {
      "id": 199,
      "callFrame": {
        "functionName": "consoleCall",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        200
      ]
    },
    {
      "id": 200,
      "callFrame": {
        "functionName": "log",
        "scriptId": "114",
        "url": "console.js",
        "lineNumber": 102,
        "columnNumber": 36
      },
      "hitCount": 0,
      "children": [
        201
      ]
    },
    {
      "id": 201,
      "callFrame": {
        "functionName": "write",
        "scriptId": "114",
        "url": "console.js",
        "lineNumber": 80,
        "columnNumber": 14
      },
      "hitCount": 0,
      "children": [
        202
      ]
    },
    {
      "id": 202,
      "callFrame": {
        "functionName": "Socket.write",
        "scriptId": "87",
        "url": "net.js",
        "lineNumber": 693,
        "columnNumber": 33
      },
      "hitCount": 0,
      "children": [
        203
      ]
    },
    {
      "id": 203,
      "callFrame": {
        "functionName": "Writable.write",
        "scriptId": "51",
        "url": "_stream_writable.js",
        "lineNumber": 247,
        "columnNumber": 35
      },
      "hitCount": 0,
      "children": [
        204
      ]
    },
    {
      "id": 204,
      "callFrame": {
        "functionName": "writeOrBuffer",
        "scriptId": "51",
        "url": "_stream_writable.js",
        "lineNumber": 322,
        "columnNumber": 22
      },
      "hitCount": 0,
      "children": [
        205
      ]
    },
    {
      "id": 205,
      "callFrame": {
        "functionName": "doWrite",
        "scriptId": "51",
        "url": "_stream_writable.js",
        "lineNumber": 362,
        "columnNumber": 16
      },
      "hitCount": 0,
      "children": [
        206
      ]
    },
    {
      "id": 206,
      "callFrame": {
        "functionName": "Socket._write",
        "scriptId": "87",
        "url": "net.js",
        "lineNumber": 779,
        "columnNumber": 34
      },
      "hitCount": 0,
      "children": [
        207
      ]
    },
    {
      "id": 207,
      "callFrame": {
        "functionName": "Socket._writeGeneric",
        "scriptId": "87",
        "url": "net.js",
        "lineNumber": 702,
        "columnNumber": 41
      },
      "hitCount": 0,
      "children": [
        208
      ]
    },
    {
      "id": 208,
      "callFrame": {
        "functionName": "createWriteReq",
        "scriptId": "87",
        "url": "net.js",
        "lineNumber": 783,
        "columnNumber": 23
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 795,
          "ticks": 1
        }
      ]
    },
    {
      "id": 80,
      "callFrame": {
        "functionName": "wait",
        "scriptId": "56",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
        "lineNumber": 23,
        "columnNumber": 14
      },
      "hitCount": 2,
      "children": [
        81,
        183,
        188
      ],
      "positionTicks": [
        {
          "line": 8,
          "ticks": 2
        }
      ]
    },
    {
      "id": 81,
      "callFrame": {
        "functionName": "",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 329,
        "columnNumber": 18
      },
      "hitCount": 1,
      "children": [
        82,
        95,
        107,
        162,
        255,
        271
      ],
      "positionTicks": [
        {
          "line": 338,
          "ticks": 1
        }
      ]
    },
    {
      "id": 82,
      "callFrame": {
        "functionName": "expand",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 250,
        "columnNumber": 15
      },
      "hitCount": 0,
      "children": [
        83
      ]
    },
    {
      "id": 83,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        84
      ]
    },
    {
      "id": 84,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        85
      ]
    },
    {
      "id": 85,
      "callFrame": {
        "functionName": "",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 255,
        "columnNumber": 24
      },
      "hitCount": 1,
      "children": [
        86
      ],
      "positionTicks": [
        {
          "line": 265,
          "ticks": 1
        }
      ]
    },
    {
      "id": 86,
      "callFrame": {
        "functionName": "globSync",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 20,
        "columnNumber": 18
      },
      "hitCount": 1,
      "children": [
        87
      ],
      "positionTicks": [
        {
          "line": 22,
          "ticks": 1
        }
      ]
    },
    {
      "id": 87,
      "callFrame": {
        "functionName": "GlobSync",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 28,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        88,
        116,
        135
      ]
    },
    {
      "id": 88,
      "callFrame": {
        "functionName": "GlobSync._process",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 76,
        "columnNumber": 39
      },
      "hitCount": 2,
      "children": [
        89,
        152
      ],
      "positionTicks": [
        {
          "line": 92,
          "ticks": 1
        },
        {
          "line": 78,
          "ticks": 1
        }
      ]
    },
    {
      "id": 89,
      "callFrame": {
        "functionName": "GlobSync._processReaddir",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 135,
        "columnNumber": 46
      },
      "hitCount": 6,
      "children": [
        90,
        131,
        196
      ],
      "positionTicks": [
        {
          "line": 137,
          "ticks": 5
        },
        {
          "line": 175,
          "ticks": 1
        }
      ]
    },
    {
      "id": 90,
      "callFrame": {
        "functionName": "GlobSync._emitMatch",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 14,
      "children": [
        91
      ],
      "positionTicks": [
        {
          "line": 191,
          "ticks": 14
        }
      ]
    },
    {
      "id": 91,
      "callFrame": {
        "functionName": "GlobSync._makeAbs",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        92
      ]
    },
    {
      "id": 92,
      "callFrame": {
        "functionName": "makeAbs",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        93
      ]
    },
    {
      "id": 93,
      "callFrame": {
        "functionName": "resolve",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 1151,
        "columnNumber": 27
      },
      "hitCount": 4,
      "children": [
        94,
        104
      ],
      "positionTicks": [
        {
          "line": 1162,
          "ticks": 1
        },
        {
          "line": 1157,
          "ticks": 2
        },
        {
          "line": 1189,
          "ticks": 1
        }
      ]
    },
    {
      "id": 94,
      "callFrame": {
        "functionName": "cwd",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 108,
      "positionTicks": [
        {
          "line": 1162,
          "ticks": 108
        }
      ]
    },
    {
      "id": 104,
      "callFrame": {
        "functionName": "normalizeStringPosix",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 98,
        "columnNumber": 29
      },
      "hitCount": 16,
      "children": [
        134
      ],
      "positionTicks": [
        {
          "line": 148,
          "ticks": 1
        },
        {
          "line": 149,
          "ticks": 1
        },
        {
          "line": 151,
          "ticks": 2
        },
        {
          "line": 104,
          "ticks": 2
        },
        {
          "line": 106,
          "ticks": 5
        },
        {
          "line": 107,
          "ticks": 3
        },
        {
          "line": 143,
          "ticks": 2
        }
      ]
    },
    {
      "id": 134,
      "callFrame": {
        "functionName": "slice",
        "scriptId": "7",
        "url": "native string.js",
        "lineNumber": 40,
        "columnNumber": 20
      },
      "hitCount": 3,
      "positionTicks": [
        {
          "line": 41,
          "ticks": 3
        }
      ]
    },
    {
      "id": 131,
      "callFrame": {
        "functionName": "GlobSync._readdir",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 271,
        "columnNumber": 39
      },
      "hitCount": 1,
      "children": [
        132,
        138,
        156
      ],
      "positionTicks": [
        {
          "line": 278,
          "ticks": 1
        }
      ]
    },
    {
      "id": 132,
      "callFrame": {
        "functionName": "fs.readdirSync",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 904,
        "columnNumber": 25
      },
      "hitCount": 3,
      "children": [
        133
      ],
      "positionTicks": [
        {
          "line": 906,
          "ticks": 3
        }
      ]
    },
    {
      "id": 133,
      "callFrame": {
        "functionName": "readdir",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 39,
      "children": [
        267
      ],
      "positionTicks": [
        {
          "line": 906,
          "ticks": 38
        }
      ]
    },
    {
      "id": 267,
      "callFrame": {
        "functionName": "pushValueToArray",
        "scriptId": "22",
        "url": "bootstrap_node.js",
        "lineNumber": 208,
        "columnNumber": 29
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 210,
          "ticks": 1
        }
      ]
    },
    {
      "id": 138,
      "callFrame": {
        "functionName": "ownProp",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 10,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        139
      ]
    },
    {
      "id": 139,
      "callFrame": {
        "functionName": "hasOwnProperty",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 2
    },
    {
      "id": 156,
      "callFrame": {
        "functionName": "GlobSync._readdirEntries",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 294,
        "columnNumber": 46
      },
      "hitCount": 15,
      "positionTicks": [
        {
          "line": 302,
          "ticks": 15
        }
      ]
    },
    {
      "id": 196,
      "callFrame": {
        "functionName": "match",
        "scriptId": "7",
        "url": "native string.js",
        "lineNumber": 16,
        "columnNumber": 22
      },
      "hitCount": 0,
      "children": [
        197
      ]
    },
    {
      "id": 197,
      "callFrame": {
        "functionName": "[Symbol.match]",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        198
      ]
    },
    {
      "id": 198,
      "callFrame": {
        "functionName": "exec",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 3
    },
    {
      "id": 152,
      "callFrame": {
        "functionName": "GlobSync._makeAbs",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        153
      ]
    },
    {
      "id": 153,
      "callFrame": {
        "functionName": "makeAbs",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        154
      ]
    },
    {
      "id": 154,
      "callFrame": {
        "functionName": "resolve",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 1151,
        "columnNumber": 27
      },
      "hitCount": 0,
      "children": [
        155,
        256
      ]
    },
    {
      "id": 155,
      "callFrame": {
        "functionName": "cwd",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 7,
      "positionTicks": [
        {
          "line": 1162,
          "ticks": 7
        }
      ]
    },
    {
      "id": 256,
      "callFrame": {
        "functionName": "normalizeStringPosix",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 98,
        "columnNumber": 29
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 107,
          "ticks": 1
        }
      ]
    },
    {
      "id": 116,
      "callFrame": {
        "functionName": "GlobSync._finish",
        "scriptId": "69",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
        "lineNumber": 52,
        "columnNumber": 38
      },
      "hitCount": 0,
      "children": [
        117
      ]
    },
    {
      "id": 117,
      "callFrame": {
        "functionName": "finish",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 121,
        "columnNumber": 16
      },
      "hitCount": 9,
      "children": [
        118,
        157
      ],
      "positionTicks": [
        {
          "line": 128,
          "ticks": 7
        },
        {
          "line": 139,
          "ticks": 1
        },
        {
          "line": 124,
          "ticks": 1
        }
      ]
    },
    {
      "id": 118,
      "callFrame": {
        "functionName": "sort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 748,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        119
      ]
    },
    {
      "id": 119,
      "callFrame": {
        "functionName": "InnerArraySort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 529,
        "columnNumber": 23
      },
      "hitCount": 0,
      "children": [
        120
      ]
    },
    {
      "id": 120,
      "callFrame": {
        "functionName": "QuickSort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 573,
        "columnNumber": 18
      },
      "hitCount": 1,
      "children": [
        121,
        129,
        140,
        178
      ],
      "positionTicks": [
        {
          "line": 574,
          "ticks": 1
        }
      ]
    },
    {
      "id": 121,
      "callFrame": {
        "functionName": "alphasort",
        "scriptId": "70",
        "url": "native array.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        122
      ]
    },
    {
      "id": 122,
      "callFrame": {
        "functionName": "localeCompare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1228,
        "columnNumber": 38
      },
      "hitCount": 2,
      "children": [
        123,
        248
      ],
      "deoptReason": "Bad value context for arguments value",
      "positionTicks": [
        {
          "line": 1229,
          "ticks": 2
        }
      ]
    },
    {
      "id": 123,
      "callFrame": {
        "functionName": "compare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 654,
        "columnNumber": 16
      },
      "hitCount": 10,
      "positionTicks": [
        {
          "line": 655,
          "ticks": 10
        }
      ]
    },
    {
      "id": 248,
      "callFrame": {
        "functionName": "cachedOrNewService",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1201,
        "columnNumber": 27
      },
      "hitCount": 0,
      "children": [
        249
      ]
    },
    {
      "id": 249,
      "callFrame": {
        "functionName": "checkDateCacheCurrent",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1193,
        "columnNumber": 30
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 1194,
          "ticks": 1
        }
      ]
    },
    {
      "id": 129,
      "callFrame": {
        "functionName": "localeCompare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1228,
        "columnNumber": 38
      },
      "hitCount": 1,
      "children": [
        130
      ],
      "deoptReason": "Bad value context for arguments value",
      "positionTicks": [
        {
          "line": 1229,
          "ticks": 1
        }
      ]
    },
    {
      "id": 130,
      "callFrame": {
        "functionName": "compare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 654,
        "columnNumber": 16
      },
      "hitCount": 4,
      "positionTicks": [
        {
          "line": 655,
          "ticks": 4
        }
      ]
    },
    {
      "id": 140,
      "callFrame": {
        "functionName": "InsertionSort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 542,
        "columnNumber": 22
      },
      "hitCount": 0,
      "children": [
        141
      ]
    },
    {
      "id": 141,
      "callFrame": {
        "functionName": "alphasort",
        "scriptId": "70",
        "url": "native array.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        142
      ]
    },
    {
      "id": 142,
      "callFrame": {
        "functionName": "localeCompare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1228,
        "columnNumber": 38
      },
      "hitCount": 1,
      "children": [
        143,
        160
      ],
      "deoptReason": "Bad value context for arguments value",
      "positionTicks": [
        {
          "line": 1229,
          "ticks": 1
        }
      ]
    },
    {
      "id": 143,
      "callFrame": {
        "functionName": "compare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 654,
        "columnNumber": 16
      },
      "hitCount": 3,
      "positionTicks": [
        {
          "line": 655,
          "ticks": 3
        }
      ]
    },
    {
      "id": 160,
      "callFrame": {
        "functionName": "cachedOrNewService",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1201,
        "columnNumber": 27
      },
      "hitCount": 0,
      "children": [
        161
      ]
    },
    {
      "id": 161,
      "callFrame": {
        "functionName": "checkDateCacheCurrent",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1193,
        "columnNumber": 30
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 1194,
          "ticks": 1
        }
      ]
    },
    {
      "id": 178,
      "callFrame": {
        "functionName": "QuickSort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 573,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        179
      ]
    },
    {
      "id": 179,
      "callFrame": {
        "functionName": "InsertionSort",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 542,
        "columnNumber": 22
      },
      "hitCount": 0,
      "children": [
        180
      ]
    },
    {
      "id": 180,
      "callFrame": {
        "functionName": "alphasort",
        "scriptId": "70",
        "url": "native array.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        181
      ]
    },
    {
      "id": 181,
      "callFrame": {
        "functionName": "localeCompare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 1228,
        "columnNumber": 38
      },
      "hitCount": 0,
      "children": [
        182
      ],
      "deoptReason": "Bad value context for arguments value"
    },
    {
      "id": 182,
      "callFrame": {
        "functionName": "compare",
        "scriptId": "19",
        "url": "native i18n.js",
        "lineNumber": 654,
        "columnNumber": 16
      },
      "hitCount": 6,
      "positionTicks": [
        {
          "line": 655,
          "ticks": 6
        }
      ]
    },
    {
      "id": 157,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        158
      ]
    },
    {
      "id": 158,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 1,
      "children": [
        159
      ],
      "positionTicks": [
        {
          "line": 776,
          "ticks": 1
        }
      ]
    },
    {
      "id": 159,
      "callFrame": {
        "functionName": "",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 142,
        "columnNumber": 27
      },
      "hitCount": 8,
      "positionTicks": [
        {
          "line": 143,
          "ticks": 8
        }
      ]
    },
    {
      "id": 135,
      "callFrame": {
        "functionName": "setopts",
        "scriptId": "70",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": 52,
        "columnNumber": 17
      },
      "hitCount": 4,
      "children": [
        136,
        144
      ],
      "positionTicks": [
        {
          "line": 113,
          "ticks": 1
        },
        {
          "line": 98,
          "ticks": 1
        },
        {
          "line": 69,
          "ticks": 1
        },
        {
          "line": 62,
          "ticks": 1
        }
      ]
    },
    {
      "id": 136,
      "callFrame": {
        "functionName": "cwd",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 16,
      "positionTicks": [
        {
          "line": 93,
          "ticks": 16
        }
      ]
    },
    {
      "id": 144,
      "callFrame": {
        "functionName": "Minimatch",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        145
      ]
    },
    {
      "id": 145,
      "callFrame": {
        "functionName": "make",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/minimatch/minimatch.js",
        "lineNumber": 141,
        "columnNumber": 14
      },
      "hitCount": 0,
      "children": [
        146
      ]
    },
    {
      "id": 146,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        147
      ]
    },
    {
      "id": 147,
      "callFrame": {
        "functionName": "",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/minimatch/minimatch.js",
        "lineNumber": 180,
        "columnNumber": 25
      },
      "hitCount": 0,
      "children": [
        148
      ]
    },
    {
      "id": 148,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        149
      ]
    },
    {
      "id": 149,
      "callFrame": {
        "functionName": "parse",
        "scriptId": "63",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/minimatch/minimatch.js",
        "lineNumber": 270,
        "columnNumber": 15
      },
      "hitCount": 10,
      "children": [
        272
      ],
      "positionTicks": [
        {
          "line": 271,
          "ticks": 2
        },
        {
          "line": 561,
          "ticks": 1
        },
        {
          "line": 273,
          "ticks": 1
        },
        {
          "line": 276,
          "ticks": 1
        },
        {
          "line": 359,
          "ticks": 1
        },
        {
          "line": 296,
          "ticks": 2
        },
        {
          "line": 286,
          "ticks": 1
        },
        {
          "line": 510,
          "ticks": 1
        }
      ]
    },
    {
      "id": 272,
      "callFrame": {
        "functionName": "RegExp",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 2
    },
    {
      "id": 95,
      "callFrame": {
        "functionName": "_ls",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 42,
        "columnNumber": 12
      },
      "hitCount": 2,
      "children": [
        96
      ],
      "deoptReason": "Assignment to parameter in arguments object",
      "positionTicks": [
        {
          "line": 43,
          "ticks": 2
        }
      ]
    },
    {
      "id": 96,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        97
      ]
    },
    {
      "id": 97,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 2,
      "children": [
        98
      ],
      "positionTicks": [
        {
          "line": 776,
          "ticks": 2
        }
      ]
    },
    {
      "id": 98,
      "callFrame": {
        "functionName": "",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 72,
        "columnNumber": 25
      },
      "hitCount": 3,
      "children": [
        99,
        105,
        112,
        185,
        186
      ],
      "positionTicks": [
        {
          "line": 77,
          "ticks": 3
        }
      ]
    },
    {
      "id": 99,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        100
      ]
    },
    {
      "id": 100,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 8,
      "children": [
        101
      ],
      "positionTicks": [
        {
          "line": 776,
          "ticks": 8
        }
      ]
    },
    {
      "id": 101,
      "callFrame": {
        "functionName": "",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 100,
        "columnNumber": 43
      },
      "hitCount": 26,
      "children": [
        102,
        177
      ],
      "positionTicks": [
        {
          "line": 102,
          "ticks": 23
        },
        {
          "line": 103,
          "ticks": 3
        }
      ]
    },
    {
      "id": 102,
      "callFrame": {
        "functionName": "join",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 1225,
        "columnNumber": 21
      },
      "hitCount": 13,
      "children": [
        103
      ],
      "positionTicks": [
        {
          "line": 1240,
          "ticks": 1
        },
        {
          "line": 1232,
          "ticks": 2
        },
        {
          "line": 1234,
          "ticks": 1
        },
        {
          "line": 1227,
          "ticks": 6
        },
        {
          "line": 1237,
          "ticks": 2
        },
        {
          "line": 1230,
          "ticks": 1
        }
      ]
    },
    {
      "id": 103,
      "callFrame": {
        "functionName": "normalize",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 1196,
        "columnNumber": 31
      },
      "hitCount": 58,
      "children": [
        114
      ],
      "positionTicks": [
        {
          "line": 1209,
          "ticks": 1
        },
        {
          "line": 1203,
          "ticks": 49
        },
        {
          "line": 1204,
          "ticks": 1
        },
        {
          "line": 1198,
          "ticks": 5
        },
        {
          "line": 1207,
          "ticks": 2
        }
      ]
    },
    {
      "id": 114,
      "callFrame": {
        "functionName": "normalizeStringPosix",
        "scriptId": "41",
        "url": "path.js",
        "lineNumber": 98,
        "columnNumber": 29
      },
      "hitCount": 98,
      "children": [
        115
      ],
      "positionTicks": [
        {
          "line": 129,
          "ticks": 2
        },
        {
          "line": 114,
          "ticks": 1
        },
        {
          "line": 148,
          "ticks": 26
        },
        {
          "line": 149,
          "ticks": 4
        },
        {
          "line": 151,
          "ticks": 2
        },
        {
          "line": 104,
          "ticks": 20
        },
        {
          "line": 105,
          "ticks": 13
        },
        {
          "line": 106,
          "ticks": 8
        },
        {
          "line": 107,
          "ticks": 14
        },
        {
          "line": 143,
          "ticks": 8
        }
      ]
    },
    {
      "id": 115,
      "callFrame": {
        "functionName": "slice",
        "scriptId": "7",
        "url": "native string.js",
        "lineNumber": 40,
        "columnNumber": 20
      },
      "hitCount": 42,
      "positionTicks": [
        {
          "line": 41,
          "ticks": 42
        }
      ]
    },
    {
      "id": 177,
      "callFrame": {
        "functionName": "pushFile",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 59,
        "columnNumber": 19
      },
      "hitCount": 9,
      "positionTicks": [
        {
          "line": 61,
          "ticks": 7
        },
        {
          "line": 69,
          "ticks": 1
        },
        {
          "line": 62,
          "ticks": 1
        }
      ]
    },
    {
      "id": 105,
      "callFrame": {
        "functionName": "fs.readdirSync",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 904,
        "columnNumber": 25
      },
      "hitCount": 29,
      "children": [
        106,
        195,
        270
      ],
      "positionTicks": [
        {
          "line": 906,
          "ticks": 29
        }
      ]
    },
    {
      "id": 106,
      "callFrame": {
        "functionName": "readdir",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 404,
      "children": [
        137
      ],
      "positionTicks": [
        {
          "line": 906,
          "ticks": 400
        }
      ]
    },
    {
      "id": 137,
      "callFrame": {
        "functionName": "pushValueToArray",
        "scriptId": "22",
        "url": "bootstrap_node.js",
        "lineNumber": 208,
        "columnNumber": 29
      },
      "hitCount": 5,
      "positionTicks": [
        {
          "line": 210,
          "ticks": 5
        }
      ]
    },
    {
      "id": 195,
      "callFrame": {
        "functionName": "getPathFromURL",
        "scriptId": "38",
        "url": "fs.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 1433,
          "ticks": 1
        }
      ]
    },
    {
      "id": 270,
      "callFrame": {
        "functionName": "handleError",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 907,
          "ticks": 1
        }
      ]
    },
    {
      "id": 112,
      "callFrame": {
        "functionName": "fs.lstatSync",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 942,
        "columnNumber": 23
      },
      "hitCount": 5,
      "children": [
        113,
        125,
        150,
        187
      ],
      "positionTicks": [
        {
          "line": 944,
          "ticks": 1
        },
        {
          "line": 947,
          "ticks": 3
        },
        {
          "line": 159,
          "ticks": 1
        }
      ]
    },
    {
      "id": 113,
      "callFrame": {
        "functionName": "lstat",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 36,
      "positionTicks": [
        {
          "line": 947,
          "ticks": 36
        }
      ]
    },
    {
      "id": 125,
      "callFrame": {
        "functionName": "getPathFromURL",
        "scriptId": "38",
        "url": "fs.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 2,
      "positionTicks": [
        {
          "line": 1433,
          "ticks": 2
        }
      ]
    },
    {
      "id": 150,
      "callFrame": {
        "functionName": "statsFromValues",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1,
      "children": [
        151
      ],
      "positionTicks": [
        {
          "line": 1439,
          "ticks": 1
        }
      ]
    },
    {
      "id": 151,
      "callFrame": {
        "functionName": "Stats",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 173,
        "columnNumber": 14
      },
      "hitCount": 12,
      "positionTicks": [
        {
          "line": 203,
          "ticks": 10
        },
        {
          "line": 204,
          "ticks": 2
        }
      ]
    },
    {
      "id": 187,
      "callFrame": {
        "functionName": "handleError",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 944,
          "ticks": 1
        }
      ]
    },
    {
      "id": 185,
      "callFrame": {
        "functionName": "pushFile",
        "scriptId": "92",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
        "lineNumber": 59,
        "columnNumber": 19
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 61,
          "ticks": 1
        }
      ]
    },
    {
      "id": 186,
      "callFrame": {
        "functionName": "Stats.isDirectory",
        "scriptId": "45",
        "url": "fs.js",
        "lineNumber": 213,
        "columnNumber": 38
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 215,
          "ticks": 1
        }
      ]
    },
    {
      "id": 107,
      "callFrame": {
        "functionName": "ShellString",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 150,
        "columnNumber": 20
      },
      "hitCount": 0,
      "children": [
        108,
        126
      ]
    },
    {
      "id": 108,
      "callFrame": {
        "functionName": "join",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 287,
        "columnNumber": 18
      },
      "hitCount": 0,
      "children": [
        109
      ]
    },
    {
      "id": 109,
      "callFrame": {
        "functionName": "InnerArrayJoin",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 274,
        "columnNumber": 23
      },
      "hitCount": 0,
      "children": [
        110
      ]
    },
    {
      "id": 110,
      "callFrame": {
        "functionName": "Join",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 120,
        "columnNumber": 13
      },
      "hitCount": 0,
      "children": [
        111,
        254
      ]
    },
    {
      "id": 111,
      "callFrame": {
        "functionName": "DoJoin",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 95,
        "columnNumber": 15
      },
      "hitCount": 28,
      "children": [
        194
      ],
      "positionTicks": [
        {
          "line": 96,
          "ticks": 28
        }
      ]
    },
    {
      "id": 194,
      "callFrame": {
        "functionName": "ConvertToString",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 133,
        "columnNumber": 24
      },
      "hitCount": 2,
      "positionTicks": [
        {
          "line": 134,
          "ticks": 2
        }
      ]
    },
    {
      "id": 254,
      "callFrame": {
        "functionName": "StackPush",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 80,
        "columnNumber": 18
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 81,
          "ticks": 1
        }
      ]
    },
    {
      "id": 126,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        127
      ]
    },
    {
      "id": 127,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        128
      ]
    },
    {
      "id": 128,
      "callFrame": {
        "functionName": "",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 164,
        "columnNumber": 31
      },
      "hitCount": 2,
      "children": [
        193
      ],
      "positionTicks": [
        {
          "line": 166,
          "ticks": 2
        }
      ]
    },
    {
      "id": 193,
      "callFrame": {
        "functionName": "ConvertToString",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 133,
        "columnNumber": 24
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 134,
          "ticks": 1
        }
      ]
    },
    {
      "id": 162,
      "callFrame": {
        "functionName": "parseOptions",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 189,
        "columnNumber": 21
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 202,
          "ticks": 1
        }
      ]
    },
    {
      "id": 255,
      "callFrame": {
        "functionName": "keys",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1
    },
    {
      "id": 271,
      "callFrame": {
        "functionName": "getUserHome",
        "scriptId": "58",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
        "lineNumber": 174,
        "columnNumber": 20
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 178,
          "ticks": 1
        }
      ]
    },
    {
      "id": 183,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 0,
      "children": [
        184
      ]
    },
    {
      "id": 184,
      "callFrame": {
        "functionName": "visit",
        "scriptId": "113",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_parse-section.js",
        "lineNumber": 0,
        "columnNumber": 93
      },
      "hitCount": 3,
      "children": [
        257
      ],
      "positionTicks": [
        {
          "line": 6,
          "ticks": 3
        }
      ]
    },
    {
      "id": 257,
      "callFrame": {
        "functionName": "parseMembers",
        "scriptId": "113",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_parse-section.js",
        "lineNumber": 14,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        258
      ]
    },
    {
      "id": 258,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        259
      ]
    },
    {
      "id": 259,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 776,
          "ticks": 1
        }
      ]
    },
    {
      "id": 188,
      "callFrame": {
        "functionName": "parseArcFile",
        "scriptId": "110",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        189,
        252
      ]
    },
    {
      "id": 189,
      "callFrame": {
        "functionName": "getSections",
        "scriptId": "112",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_get-sections.js",
        "lineNumber": 0,
        "columnNumber": 99
      },
      "hitCount": 1,
      "children": [
        190,
        250,
        260
      ],
      "positionTicks": [
        {
          "line": 3,
          "ticks": 1
        }
      ]
    },
    {
      "id": 190,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        191
      ]
    },
    {
      "id": 191,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        192
      ]
    },
    {
      "id": 192,
      "callFrame": {
        "functionName": "sections.forEach.section",
        "scriptId": "112",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_get-sections.js",
        "lineNumber": 13,
        "columnNumber": 19
      },
      "hitCount": 1,
      "children": [
        261
      ],
      "positionTicks": [
        {
          "line": 17,
          "ticks": 1
        }
      ]
    },
    {
      "id": 261,
      "callFrame": {
        "functionName": "forEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 793,
        "columnNumber": 21
      },
      "hitCount": 0,
      "children": [
        262
      ]
    },
    {
      "id": 262,
      "callFrame": {
        "functionName": "InnerArrayForEach",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 775,
        "columnNumber": 26
      },
      "hitCount": 0,
      "children": [
        263
      ]
    },
    {
      "id": 263,
      "callFrame": {
        "functionName": "clone.forEach.val",
        "scriptId": "112",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_get-sections.js",
        "lineNumber": 32,
        "columnNumber": 18
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 50,
          "ticks": 1
        }
      ]
    },
    {
      "id": 250,
      "callFrame": {
        "functionName": "filter",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 767,
        "columnNumber": 20
      },
      "hitCount": 0,
      "children": [
        251
      ]
    },
    {
      "id": 251,
      "callFrame": {
        "functionName": "InnerArrayFilter",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 754,
        "columnNumber": 25
      },
      "hitCount": 4,
      "positionTicks": [
        {
          "line": 755,
          "ticks": 4
        }
      ]
    },
    {
      "id": 260,
      "callFrame": {
        "functionName": "map",
        "scriptId": "6",
        "url": "native array.js",
        "lineNumber": 831,
        "columnNumber": 17
      },
      "hitCount": 1,
      "children": [
        268
      ],
      "positionTicks": [
        {
          "line": 832,
          "ticks": 1
        }
      ]
    },
    {
      "id": 268,
      "callFrame": {
        "functionName": "text.split.filter.map.c",
        "scriptId": "112",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_get-sections.js",
        "lineNumber": 10,
        "columnNumber": 53
      },
      "hitCount": 0,
      "children": [
        269
      ]
    },
    {
      "id": 269,
      "callFrame": {
        "functionName": "split",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1
    },
    {
      "id": 252,
      "callFrame": {
        "functionName": "removeComments",
        "scriptId": "111",
        "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        253
      ]
    },
    {
      "id": 253,
      "callFrame": {
        "functionName": "replace",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 1
    },
    {
      "id": 163,
      "callFrame": {
        "functionName": "consoleCall",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 0,
      "children": [
        164,
        168
      ]
    },
    {
      "id": 164,
      "callFrame": {
        "functionName": "wrapObject",
        "scriptId": "116",
        "url": "",
        "lineNumber": 33,
        "columnNumber": 112
      },
      "hitCount": 0,
      "children": [
        165
      ]
    },
    {
      "id": 165,
      "callFrame": {
        "functionName": "_wrapObject",
        "scriptId": "116",
        "url": "",
        "lineNumber": 40,
        "columnNumber": 91
      },
      "hitCount": 0,
      "children": [
        166
      ]
    },
    {
      "id": 166,
      "callFrame": {
        "functionName": "InjectedScript.RemoteObject",
        "scriptId": "116",
        "url": "",
        "lineNumber": 126,
        "columnNumber": 76
      },
      "hitCount": 0,
      "children": [
        167
      ]
    },
    {
      "id": 167,
      "callFrame": {
        "functionName": "_generatePreview",
        "scriptId": "116",
        "url": "",
        "lineNumber": 152,
        "columnNumber": 73
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 155,
          "ticks": 1
        }
      ]
    },
    {
      "id": 168,
      "callFrame": {
        "functionName": "log",
        "scriptId": "114",
        "url": "console.js",
        "lineNumber": 102,
        "columnNumber": 36
      },
      "hitCount": 0,
      "children": [
        169
      ]
    },
    {
      "id": 169,
      "callFrame": {
        "functionName": "write",
        "scriptId": "114",
        "url": "console.js",
        "lineNumber": 80,
        "columnNumber": 14
      },
      "hitCount": 0,
      "children": [
        170
      ]
    },
    {
      "id": 170,
      "callFrame": {
        "functionName": "Socket.write",
        "scriptId": "87",
        "url": "net.js",
        "lineNumber": 693,
        "columnNumber": 33
      },
      "hitCount": 0,
      "children": [
        171
      ]
    },
    {
      "id": 171,
      "callFrame": {
        "functionName": "Writable.write",
        "scriptId": "51",
        "url": "_stream_writable.js",
        "lineNumber": 247,
        "columnNumber": 35
      },
      "hitCount": 0,
      "children": [
        172
      ]
    },
    {
      "id": 172,
      "callFrame": {
        "functionName": "writeOrBuffer",
        "scriptId": "51",
        "url": "_stream_writable.js",
        "lineNumber": 322,
        "columnNumber": 22
      },
      "hitCount": 0,
      "children": [
        173
      ]
    },
    {
      "id": 173,
      "callFrame": {
        "functionName": "doWrite",
        "scriptId": "51",
        "url": "_stream_writable.js",
        "lineNumber": 362,
        "columnNumber": 16
      },
      "hitCount": 0,
      "children": [
        174
      ]
    },
    {
      "id": 174,
      "callFrame": {
        "functionName": "Socket._write",
        "scriptId": "87",
        "url": "net.js",
        "lineNumber": 779,
        "columnNumber": 34
      },
      "hitCount": 0,
      "children": [
        175
      ]
    },
    {
      "id": 175,
      "callFrame": {
        "functionName": "Socket._writeGeneric",
        "scriptId": "87",
        "url": "net.js",
        "lineNumber": 702,
        "columnNumber": 41
      },
      "hitCount": 0,
      "children": [
        176
      ]
    },
    {
      "id": 176,
      "callFrame": {
        "functionName": "createWriteReq",
        "scriptId": "87",
        "url": "net.js",
        "lineNumber": 783,
        "columnNumber": 23
      },
      "hitCount": 1,
      "positionTicks": [
        {
          "line": 795,
          "ticks": 1
        }
      ]
    },
    {
      "id": 37,
      "callFrame": {
        "functionName": "(program)",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 2144
    },
    {
      "id": 124,
      "callFrame": {
        "functionName": "(garbage collector)",
        "scriptId": "0",
        "url": "",
        "lineNumber": -1,
        "columnNumber": -1
      },
      "hitCount": 8
    }
  ],
  "startTime": 3034895532937,
  "endTime": 3034900553656,
  "samples": [
    15,
    20,
    22,
    35,
    36,
    36,
    35,
    35,
    36,
    39,
    30,
    34,
    36,
    20,
    35,
    38,
    44,
    18,
    36,
    45,
    20,
    36,
    47,
    14,
    49,
    36,
    35,
    44,
    14,
    56,
    36,
    38,
    36,
    35,
    38,
    60,
    20,
    22,
    22,
    36,
    36,
    65,
    36,
    50,
    14,
    35,
    68,
    18,
    36,
    73,
    14,
    35,
    19,
    36,
    20,
    36,
    74,
    36,
    75,
    77,
    36,
    73,
    14,
    78,
    38,
    22,
    36,
    19,
    36,
    36,
    36,
    31,
    18,
    36,
    36,
    35,
    20,
    39,
    38,
    38,
    36,
    22,
    36,
    36,
    35,
    36,
    39,
    79,
    45,
    36,
    73,
    36,
    38,
    22,
    36,
    73,
    36,
    36,
    36,
    49,
    79,
    38,
    36,
    20,
    36,
    36,
    36,
    18,
    36,
    36,
    36,
    47,
    38,
    68,
    38,
    13,
    36,
    39,
    36,
    39,
    61,
    36,
    20,
    77,
    18,
    36,
    36,
    35,
    36,
    20,
    70,
    35,
    36,
    38,
    36,
    65,
    36,
    38,
    94,
    103,
    104,
    103,
    106,
    111,
    94,
    101,
    106,
    113,
    103,
    106,
    106,
    106,
    106,
    106,
    115,
    115,
    106,
    114,
    113,
    114,
    103,
    115,
    106,
    106,
    106,
    106,
    115,
    106,
    106,
    94,
    106,
    94,
    114,
    123,
    114,
    106,
    124,
    94,
    101,
    94,
    114,
    125,
    114,
    94,
    106,
    105,
    128,
    106,
    130,
    106,
    133,
    106,
    94,
    106,
    94,
    101,
    134,
    124,
    136,
    137,
    88,
    111,
    115,
    112,
    106,
    139,
    106,
    117,
    102,
    106,
    111,
    105,
    104,
    106,
    104,
    115,
    94,
    124,
    94,
    100,
    106,
    106,
    106,
    133,
    115,
    94,
    114,
    106,
    106,
    106,
    133,
    115,
    123,
    114,
    106,
    106,
    104,
    106,
    115,
    103,
    94,
    103,
    143,
    106,
    106,
    94,
    114,
    113,
    113,
    106,
    114,
    89,
    105,
    94,
    114,
    95,
    103,
    113,
    106,
    106,
    113,
    106,
    149,
    111,
    94,
    115,
    106,
    151,
    106,
    155,
    106,
    117,
    103,
    106,
    106,
    133,
    106,
    94,
    115,
    106,
    106,
    106,
    156,
    114,
    106,
    101,
    133,
    94,
    128,
    133,
    106,
    104,
    115,
    111,
    151,
    106,
    106,
    106,
    111,
    106,
    136,
    106,
    94,
    94,
    122,
    125,
    151,
    106,
    106,
    103,
    106,
    112,
    114,
    94,
    106,
    134,
    106,
    114,
    159,
    115,
    113,
    106,
    106,
    111,
    106,
    94,
    106,
    133,
    106,
    94,
    114,
    100,
    106,
    114,
    101,
    94,
    103,
    106,
    136,
    94,
    106,
    103,
    106,
    94,
    106,
    106,
    106,
    106,
    133,
    106,
    114,
    161,
    133,
    94,
    106,
    114,
    105,
    162,
    106,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    167,
    176,
    106,
    151,
    133,
    106,
    114,
    94,
    114,
    123,
    114,
    177,
    115,
    132,
    106,
    111,
    133,
    117,
    101,
    136,
    106,
    133,
    103,
    104,
    106,
    114,
    182,
    114,
    114,
    101,
    106,
    94,
    106,
    114,
    111,
    106,
    103,
    159,
    114,
    106,
    133,
    106,
    90,
    106,
    136,
    106,
    94,
    114,
    106,
    114,
    106,
    103,
    111,
    94,
    117,
    151,
    117,
    103,
    90,
    114,
    106,
    115,
    106,
    151,
    106,
    133,
    117,
    114,
    106,
    149,
    184,
    106,
    139,
    105,
    135,
    106,
    184,
    156,
    105,
    94,
    114,
    185,
    106,
    149,
    106,
    106,
    106,
    101,
    94,
    106,
    156,
    114,
    130,
    102,
    106,
    186,
    115,
    106,
    102,
    106,
    187,
    106,
    136,
    106,
    104,
    115,
    106,
    113,
    106,
    115,
    103,
    111,
    133,
    106,
    106,
    115,
    94,
    106,
    114,
    155,
    106,
    106,
    115,
    94,
    94,
    114,
    94,
    103,
    103,
    101,
    94,
    94,
    94,
    90,
    105,
    115,
    94,
    106,
    115,
    106,
    192,
    106,
    90,
    114,
    106,
    114,
    106,
    184,
    101,
    106,
    106,
    106,
    106,
    114,
    106,
    94,
    129,
    106,
    193,
    106,
    156,
    114,
    158,
    114,
    106,
    106,
    94,
    114,
    106,
    106,
    94,
    130,
    94,
    155,
    106,
    194,
    106,
    106,
    106,
    106,
    133,
    94,
    101,
    151,
    98,
    106,
    106,
    106,
    113,
    106,
    189,
    159,
    106,
    106,
    113,
    94,
    102,
    104,
    106,
    182,
    106,
    100,
    106,
    194,
    106,
    106,
    195,
    101,
    106,
    106,
    106,
    149,
    106,
    94,
    102,
    123,
    114,
    106,
    111,
    115,
    106,
    94,
    106,
    106,
    114,
    100,
    198,
    123,
    208,
    36,
    36,
    36,
    36,
    36,
    49,
    14,
    209,
    36,
    49,
    36,
    38,
    47,
    36,
    38,
    36,
    19,
    36,
    49,
    36,
    73,
    36,
    36,
    36,
    210,
    36,
    35,
    18,
    36,
    36,
    36,
    77,
    30,
    36,
    217,
    36,
    36,
    218,
    35,
    39,
    77,
    35,
    38,
    221,
    19,
    36,
    22,
    223,
    224,
    21,
    36,
    56,
    49,
    36,
    36,
    73,
    36,
    49,
    20,
    36,
    36,
    39,
    38,
    19,
    124,
    36,
    35,
    38,
    229,
    38,
    14,
    38,
    49,
    36,
    78,
    39,
    45,
    36,
    36,
    231,
    38,
    232,
    38,
    35,
    19,
    49,
    36,
    35,
    38,
    36,
    20,
    36,
    73,
    14,
    35,
    38,
    233,
    36,
    36,
    14,
    22,
    36,
    36,
    38,
    20,
    18,
    223,
    36,
    22,
    235,
    36,
    73,
    36,
    75,
    36,
    47,
    20,
    49,
    36,
    35,
    39,
    77,
    20,
    39,
    38,
    47,
    38,
    36,
    20,
    30,
    38,
    239,
    36,
    239,
    36,
    224,
    38,
    35,
    38,
    10,
    38,
    36,
    240,
    36,
    35,
    36,
    49,
    36,
    35,
    45,
    18,
    38,
    36,
    73,
    35,
    36,
    20,
    36,
    36,
    36,
    39,
    243,
    20,
    38,
    39,
    36,
    36,
    36,
    245,
    239,
    31,
    39,
    35,
    36,
    38,
    247,
    77,
    36,
    36,
    38,
    36,
    35,
    36,
    36,
    35,
    45,
    35,
    14,
    35,
    38,
    39,
    22,
    45,
    38,
    239,
    229,
    36,
    213,
    36,
    21,
    36,
    75,
    36,
    35,
    36,
    73,
    36,
    231,
    36,
    22,
    19,
    22,
    31,
    19,
    35,
    36,
    49,
    38,
    35,
    20,
    30,
    39,
    229,
    38,
    22,
    36,
    36,
    73,
    36,
    133,
    114,
    117,
    177,
    101,
    113,
    105,
    106,
    106,
    94,
    106,
    104,
    94,
    249,
    94,
    106,
    106,
    113,
    104,
    106,
    106,
    106,
    156,
    114,
    106,
    101,
    106,
    106,
    101,
    177,
    133,
    106,
    115,
    251,
    106,
    101,
    106,
    106,
    124,
    89,
    115,
    114,
    106,
    106,
    106,
    155,
    106,
    106,
    106,
    106,
    106,
    114,
    106,
    253,
    106,
    93,
    103,
    94,
    114,
    100,
    106,
    114,
    106,
    94,
    113,
    136,
    133,
    106,
    106,
    114,
    106,
    149,
    113,
    103,
    117,
    115,
    106,
    111,
    106,
    113,
    106,
    136,
    105,
    94,
    114,
    106,
    106,
    80,
    93,
    106,
    111,
    106,
    94,
    103,
    182,
    106,
    94,
    114,
    115,
    113,
    114,
    120,
    105,
    94,
    177,
    182,
    114,
    104,
    106,
    94,
    105,
    94,
    103,
    143,
    103,
    106,
    251,
    106,
    94,
    114,
    135,
    106,
    89,
    114,
    94,
    106,
    155,
    105,
    106,
    93,
    103,
    103,
    106,
    113,
    101,
    106,
    101,
    104,
    106,
    137,
    136,
    156,
    105,
    156,
    106,
    115,
    114,
    103,
    150,
    102,
    80,
    106,
    114,
    90,
    90,
    182,
    106,
    105,
    113,
    114,
    114,
    106,
    177,
    106,
    122,
    115,
    106,
    106,
    106,
    133,
    106,
    106,
    97,
    106,
    101,
    106,
    137,
    106,
    133,
    115,
    90,
    103,
    106,
    254,
    94,
    133,
    106,
    94,
    114,
    94,
    114,
    94,
    106,
    132,
    106,
    106,
    114,
    106,
    103,
    159,
    114,
    94,
    114,
    90,
    103,
    106,
    94,
    94,
    94,
    106,
    113,
    106,
    106,
    106,
    133,
    105,
    131,
    106,
    94,
    102,
    94,
    103,
    106,
    106,
    106,
    106,
    106,
    133,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    94,
    104,
    123,
    106,
    106,
    114,
    106,
    106,
    106,
    102,
    106,
    102,
    106,
    98,
    136,
    151,
    114,
    255,
    103,
    130,
    115,
    136,
    114,
    106,
    113,
    106,
    106,
    106,
    156,
    106,
    106,
    106,
    106,
    81,
    111,
    103,
    94,
    114,
    106,
    113,
    106,
    114,
    113,
    106,
    114,
    94,
    106,
    106,
    133,
    94,
    106,
    106,
    256,
    106,
    156,
    106,
    114,
    106,
    106,
    259,
    106,
    106,
    90,
    114,
    111,
    198,
    106,
    101,
    156,
    106,
    94,
    114,
    94,
    106,
    260,
    106,
    156,
    103,
    94,
    103,
    97,
    103,
    106,
    106,
    177,
    106,
    106,
    106,
    133,
    103,
    94,
    106,
    89,
    103,
    106,
    103,
    94,
    114,
    106,
    103,
    115,
    106,
    106,
    133,
    106,
    111,
    105,
    132,
    177,
    94,
    106,
    101,
    156,
    106,
    103,
    106,
    106,
    111,
    106,
    133,
    106,
    133,
    156,
    106,
    113,
    123,
    137,
    94,
    103,
    112,
    102,
    106,
    111,
    106,
    111,
    137,
    106,
    263,
    105,
    104,
    114,
    113,
    105,
    134,
    114,
    106,
    114,
    143,
    106,
    90,
    106,
    149,
    106,
    94,
    114,
    106,
    111,
    106,
    115,
    106,
    105,
    106,
    155,
    106,
    104,
    98,
    124,
    94,
    100,
    123,
    114,
    106,
    106,
    94,
    115,
    106,
    106,
    115,
    106,
    106,
    149,
    106,
    94,
    100,
    159,
    106,
    106,
    106,
    106,
    85,
    106,
    94,
    106,
    106,
    106,
    159,
    106,
    106,
    106,
    106,
    106,
    111,
    106,
    136,
    105,
    94,
    177,
    151,
    106,
    106,
    114,
    114,
    103,
    177,
    106,
    106,
    106,
    105,
    101,
    89,
    103,
    95,
    114,
    113,
    102,
    112,
    114,
    94,
    105,
    106,
    30,
    38,
    35,
    36,
    49,
    39,
    44,
    36,
    35,
    243,
    19,
    36,
    38,
    36,
    20,
    35,
    45,
    36,
    36,
    36,
    20,
    36,
    36,
    31,
    36,
    20,
    36,
    73,
    36,
    35,
    20,
    221,
    38,
    35,
    36,
    38,
    221,
    22,
    76,
    38,
    49,
    36,
    36,
    38,
    30,
    20,
    35,
    36,
    36,
    35,
    35,
    36,
    38,
    38,
    73,
    34,
    36,
    38,
    59,
    39,
    36,
    39,
    36,
    73,
    264,
    31,
    38,
    36,
    36,
    36,
    49,
    14,
    35,
    39,
    35,
    14,
    35,
    18,
    76,
    20,
    36,
    49,
    38,
    19,
    36,
    36,
    34,
    77,
    35,
    36,
    22,
    36,
    18,
    22,
    36,
    19,
    35,
    18,
    35,
    20,
    35,
    20,
    60,
    20,
    22,
    36,
    36,
    47,
    14,
    17,
    35,
    38,
    35,
    17,
    35,
    14,
    35,
    39,
    221,
    39,
    77,
    22,
    36,
    36,
    36,
    56,
    36,
    35,
    38,
    36,
    20,
    36,
    59,
    73,
    49,
    35,
    36,
    36,
    20,
    35,
    14,
    34,
    20,
    221,
    17,
    36,
    19,
    36,
    14,
    36,
    19,
    22,
    36,
    22,
    36,
    36,
    49,
    36,
    47,
    18,
    35,
    17,
    18,
    38,
    36,
    36,
    31,
    19,
    39,
    20,
    78,
    18,
    36,
    38,
    77,
    38,
    17,
    19,
    38,
    8,
    31,
    36,
    19,
    36,
    20,
    35,
    17,
    39,
    36,
    266,
    36,
    78,
    38,
    36,
    36,
    22,
    38,
    35,
    38,
    39,
    17,
    36,
    36,
    20,
    36,
    22,
    36,
    36,
    221,
    20,
    36,
    36,
    22,
    20,
    36,
    36,
    36,
    38,
    36,
    36,
    36,
    36,
    36,
    38,
    77,
    38,
    22,
    20,
    106,
    94,
    102,
    106,
    151,
    106,
    149,
    106,
    89,
    114,
    267,
    103,
    269,
    106,
    106,
    94,
    105,
    94,
    101,
    106,
    106,
    133,
    102,
    106,
    270,
    103,
    104,
    103,
    124,
    106,
    113,
    106,
    106,
    106,
    106,
    106,
    133,
    105,
    90,
    114,
    113,
    106,
    106,
    133,
    94,
    93,
    123,
    106,
    106,
    124,
    106,
    106,
    106,
    149,
    106,
    106,
    106,
    94,
    114,
    103,
    106,
    136,
    114,
    106,
    106,
    94,
    103,
    159,
    114,
    90,
    106,
    133,
    115,
    251,
    90,
    114,
    114,
    135,
    94,
    103,
    113,
    105,
    271,
    105,
    198,
    115,
    123,
    113,
    106,
    106,
    133,
    106,
    106,
    114,
    111,
    151,
    103,
    94,
    114,
    113,
    103,
    115,
    106,
    106,
    106,
    114,
    106,
    106,
    106,
    106,
    111,
    106,
    94,
    100,
    106,
    115,
    106,
    251,
    106,
    94,
    101,
    101,
    106,
    106,
    136,
    106,
    133,
    159,
    105,
    156,
    106,
    111,
    106,
    133,
    106,
    94,
    114,
    136,
    94,
    105,
    133,
    106,
    90,
    103,
    94,
    101,
    106,
    113,
    106,
    133,
    106,
    86,
    106,
    111,
    106,
    94,
    114,
    142,
    115,
    106,
    113,
    106,
    155,
    106,
    94,
    114,
    103,
    106,
    117,
    114,
    113,
    115,
    182,
    114,
    106,
    135,
    106,
    272,
    106,
    103,
    94,
    106,
    115,
    106,
    103,
    106,
    106,
    106,
    88,
    106,
    156,
    106,
    136,
    106,
    94,
    103,
    106,
    113,
    106,
    272,
    106,
    94,
    106,
    103,
    106,
    113,
    106,
    106,
    106,
    106,
    103,
    111,
    112,
    106,
    149,
    151,
    106,
    106,
    113,
    106,
    111,
    105,
    133,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37,
    37
  ],
  "timeDeltas": [
    13637,
    1165,
    1168,
    1267,
    1260,
    1089,
    3286,
    1023,
    1046,
    1251,
    1253,
    1322,
    1261,
    1272,
    1270,
    1281,
    1271,
    1286,
    1110,
    1040,
    1089,
    1046,
    1005,
    1250,
    1254,
    1252,
    1270,
    2541,
    1158,
    1273,
    1287,
    1211,
    1169,
    1268,
    1264,
    1261,
    1265,
    1247,
    1271,
    1272,
    1270,
    1273,
    1271,
    1265,
    1273,
    1269,
    2547,
    1275,
    1267,
    1273,
    1272,
    1277,
    1275,
    1299,
    1276,
    1280,
    1269,
    1273,
    1289,
    1258,
    2578,
    1276,
    1273,
    1277,
    1265,
    1276,
    2450,
    1273,
    1277,
    1269,
    1275,
    1274,
    1273,
    1275,
    1073,
    1278,
    1271,
    1275,
    1274,
    1274,
    1280,
    1273,
    1066,
    1201,
    1269,
    1267,
    2549,
    1275,
    1270,
    1285,
    1276,
    1273,
    1268,
    1268,
    1285,
    2526,
    1275,
    1275,
    1276,
    1274,
    2548,
    1277,
    1275,
    1261,
    1224,
    1277,
    1281,
    1100,
    1272,
    1277,
    1272,
    1276,
    1245,
    1277,
    1273,
    1275,
    2552,
    1276,
    1272,
    1077,
    2548,
    1275,
    2565,
    2548,
    2349,
    1276,
    1275,
    2560,
    1272,
    1272,
    1063,
    1081,
    1274,
    1270,
    1285,
    1276,
    1260,
    1087,
    1176,
    1257,
    1275,
    1265,
    1285,
    1264,
    2567,
    1275,
    1273,
    1291,
    1281,
    1304,
    1263,
    1277,
    1070,
    1272,
    1278,
    1273,
    2548,
    1272,
    1274,
    1276,
    1212,
    1110,
    1272,
    1305,
    1265,
    1289,
    1184,
    1273,
    1077,
    1274,
    1279,
    1273,
    1266,
    1271,
    1266,
    1302,
    1277,
    1275,
    1274,
    1228,
    1291,
    1276,
    1278,
    1260,
    1299,
    1082,
    1249,
    1273,
    2295,
    1278,
    1274,
    1270,
    1280,
    1271,
    1269,
    1271,
    1144,
    1269,
    1275,
    1278,
    1261,
    2553,
    1293,
    1271,
    1297,
    1273,
    1272,
    1276,
    1273,
    1280,
    1271,
    1274,
    1294,
    1272,
    1297,
    1266,
    1113,
    1272,
    1277,
    1276,
    1274,
    1277,
    1283,
    1270,
    1271,
    1270,
    1277,
    1299,
    1270,
    1299,
    1254,
    1274,
    1274,
    1275,
    1291,
    1065,
    1276,
    1136,
    1258,
    1271,
    1277,
    1271,
    1277,
    1019,
    2564,
    1272,
    1270,
    1271,
    1281,
    1271,
    1116,
    1282,
    1254,
    1269,
    1285,
    1252,
    1288,
    1252,
    1269,
    1271,
    1274,
    1285,
    1263,
    2537,
    2549,
    1275,
    1273,
    1276,
    1275,
    1275,
    1273,
    1276,
    1274,
    1275,
    2547,
    1297,
    1270,
    3825,
    1277,
    1273,
    1275,
    1273,
    1276,
    1273,
    1282,
    1269,
    1285,
    1068,
    2544,
    2543,
    1275,
    1272,
    1287,
    1264,
    2562,
    1263,
    1273,
    1275,
    1288,
    1266,
    1268,
    1276,
    1325,
    1247,
    1288,
    1265,
    1274,
    1290,
    1256,
    1273,
    1119,
    1269,
    1278,
    1270,
    1266,
    1280,
    1021,
    1274,
    1275,
    1263,
    1275,
    1246,
    1307,
    1261,
    1273,
    1296,
    1272,
    1277,
    1284,
    1274,
    1274,
    2490,
    1275,
    1075,
    1283,
    1272,
    2544,
    1019,
    1261,
    1269,
    1255,
    1276,
    1268,
    1254,
    1264,
    1248,
    1272,
    1095,
    1276,
    1275,
    1145,
    1292,
    1083,
    1273,
    1014,
    2546,
    1274,
    2540,
    1289,
    1045,
    1275,
    1287,
    1280,
    1297,
    1295,
    1295,
    1275,
    1295,
    1293,
    1296,
    1276,
    1264,
    1294,
    1402,
    1353,
    1377,
    1378,
    1378,
    1355,
    1363,
    1379,
    1379,
    1345,
    1395,
    1283,
    1365,
    1355,
    1377,
    1105,
    1154,
    1272,
    1254,
    1170,
    1396,
    1376,
    1409,
    1355,
    1136,
    1308,
    1372,
    1305,
    1363,
    1232,
    1277,
    1364,
    1388,
    1378,
    1378,
    1348,
    1388,
    1357,
    1131,
    1041,
    1365,
    1379,
    1374,
    1389,
    1356,
    1378,
    1370,
    1343,
    1404,
    1313,
    1354,
    1346,
    1360,
    1370,
    1301,
    1352,
    1372,
    1369,
    1346,
    1366,
    1277,
    1375,
    1343,
    1383,
    1380,
    1381,
    1354,
    1395,
    1275,
    1279,
    1284,
    1086,
    1262,
    1399,
    1324,
    1268,
    1358,
    1269,
    1391,
    1379,
    1378,
    1415,
    1374,
    1374,
    1373,
    1376,
    1350,
    1375,
    1378,
    1331,
    1358,
    1358,
    1389,
    1284,
    1358,
    1341,
    1084,
    1392,
    1377,
    1282,
    1261,
    1276,
    1273,
    1227,
    1270,
    1401,
    1344,
    1354,
    1372,
    1363,
    1380,
    1356,
    1389,
    1061,
    1304,
    1280,
    1318,
    1389,
    1396,
    1357,
    1062,
    1272,
    1278,
    1095,
    1155,
    1411,
    1343,
    1378,
    1380,
    1400,
    1366,
    1378,
    1379,
    1324,
    1355,
    1377,
    1198,
    1192,
    1372,
    1378,
    1155,
    1368,
    1355,
    1370,
    1354,
    1357,
    1359,
    1320,
    1393,
    1384,
    1354,
    1379,
    1379,
    1325,
    1354,
    1380,
    1381,
    1380,
    1353,
    1382,
    1379,
    1352,
    1380,
    1380,
    1382,
    1362,
    1391,
    1380,
    1380,
    1353,
    1328,
    1382,
    1310,
    1278,
    1283,
    1170,
    1128,
    1271,
    1273,
    1290,
    1362,
    1381,
    1371,
    1380,
    1381,
    1377,
    1379,
    1384,
    1149,
    1268,
    1326,
    1318,
    1293,
    1083,
    1325,
    1410,
    1358,
    1363,
    1390,
    1382,
    1344,
    1432,
    1076,
    1315,
    1346,
    1380,
    1353,
    1376,
    1355,
    1383,
    1365,
    1369,
    1250,
    1390,
    1380,
    1372,
    1378,
    1389,
    1387,
    1359,
    1360,
    1379,
    1375,
    1357,
    1340,
    1225,
    1273,
    1273,
    1276,
    1281,
    1393,
    1384,
    1387,
    1354,
    1364,
    1392,
    1354,
    1342,
    1377,
    1355,
    1365,
    1332,
    1430,
    1367,
    1377,
    1367,
    1367,
    1304,
    1378,
    1307,
    1351,
    1386,
    1249,
    1121,
    1364,
    1296,
    1362,
    1356,
    1360,
    1389,
    1374,
    1383,
    1328,
    1377,
    1292,
    1349,
    1376,
    1381,
    1388,
    1354,
    1378,
    1378,
    1376,
    1352,
    1376,
    1393,
    1362,
    1260,
    1273,
    1275,
    1277,
    1398,
    1387,
    1376,
    1352,
    1386,
    1200,
    1384,
    1377,
    1218,
    1351,
    1388,
    1379,
    1099,
    1037,
    1355,
    1379,
    1377,
    1050,
    1286,
    1385,
    1385,
    1346,
    1381,
    1380,
    1382,
    1316,
    1331,
    1342,
    1385,
    1303,
    1369,
    1378,
    1378,
    1377,
    1355,
    1378,
    1380,
    1385,
    1356,
    1380,
    1390,
    1377,
    1303,
    1333,
    1406,
    1356,
    1370,
    1377,
    1388,
    1275,
    1275,
    1272,
    1278,
    1301,
    1312,
    1294,
    1284,
    1399,
    1303,
    1355,
    1377,
    1362,
    1355,
    1366,
    1290,
    1358,
    1300,
    1396,
    1356,
    1365,
    1338,
    1362,
    1360,
    1380,
    1359,
    1249,
    1337,
    1378,
    1377,
    1360,
    1325,
    1313,
    1380,
    1378,
    1371,
    1358,
    1380,
    1356,
    1355,
    1369,
    1377,
    1376,
    1349,
    1354,
    1378,
    1378,
    1379,
    1390,
    1358,
    1343,
    1377,
    1281,
    1261,
    1275,
    1261,
    1382,
    1395,
    1146,
    1395,
    1375,
    1388,
    1355,
    1378,
    1378,
    1390,
    1356,
    1340,
    1343,
    1296,
    1387,
    1356,
    1392,
    1379,
    1378,
    1353,
    1375,
    1259,
    1372,
    1060,
    1381,
    1348,
    1357,
    1390,
    1380,
    1378,
    1359,
    1363,
    1379,
    1379,
    1346,
    1381,
    1346,
    1390,
    1376,
    1380,
    1374,
    1331,
    1357,
    1380,
    1378,
    1392,
    1353,
    1380,
    1260,
    1123,
    1279,
    1091,
    1417,
    1376,
    1356,
    1375,
    1377,
    1377,
    1359,
    1203,
    1331,
    1373,
    1353,
    1361,
    1379,
    1406,
    1377,
    1370,
    1338,
    1373,
    1378,
    1378,
    1368,
    1380,
    1379,
    1374,
    1356,
    1398,
    1339,
    1387,
    1343,
    1390,
    1375,
    1377,
    1360,
    1386,
    1282,
    1358,
    1386,
    1310,
    1352,
    1349,
    1371,
    1390,
    1386,
    1376,
    1364,
    1354,
    1351,
    1266,
    1266,
    1282,
    1143,
    1011,
    1399,
    1376,
    1356,
    1378,
    1372,
    1394,
    1388,
    1357,
    1247,
    1355,
    1394,
    1358,
    1367,
    1364,
    1082,
    1365,
    1367,
    1365,
    1319,
    1357,
    1322,
    1269,
    1315,
    1246,
    1188,
    1363,
    1376,
    1377,
    1343,
    1229,
    1370,
    1137,
    1359,
    1349,
    1352,
    1373,
    1342,
    1377,
    1386,
    1376,
    1342,
    1376,
    1376,
    1375,
    1341,
    1374,
    1414,
    1362,
    1270,
    1276,
    1202,
    1280,
    1394,
    1375,
    1379,
    1355,
    1388,
    1054,
    1307,
    1388,
    1262,
    1059,
    1395,
    1359,
    1343,
    1403,
    1377,
    1304,
    1393,
    1380,
    1359,
    1095,
    1345,
    1397,
    1419,
    1217,
    1359,
    1379,
    1379,
    1380,
    1387,
    1364,
    1344,
    1380,
    1353,
    1378,
    1379,
    1019,
    1361,
    1380,
    1393,
    1390,
    1354,
    1382,
    1383,
    1195,
    1319,
    1380,
    1370,
    1398,
    1358,
    1280,
    1280,
    1282,
    1270,
    1132,
    1397,
    1212,
    1297,
    1357,
    1167,
    1384,
    1389,
    1355,
    1299,
    1380,
    1378,
    1345,
    1374,
    1354,
    1388,
    1377,
    1386,
    1357,
    1365,
    1379,
    1361,
    1395,
    1359,
    1358,
    1359,
    1372,
    1023,
    1364,
    1380,
    1377,
    1378,
    1356,
    1362,
    1105,
    1348,
    1327,
    1376,
    1344,
    1087,
    1366,
    1374,
    1389,
    1391,
    1346,
    1355,
    1346,
    1368,
    1261,
    1262,
    1291,
    1260,
    1262,
    1404,
    1376,
    1036,
    1372,
    1360,
    1377,
    1378,
    1339,
    1379,
    1377,
    1376,
    1357,
    1301,
    1203,
    1394,
    1363,
    1357,
    1375,
    1377,
    1355,
    1320,
    1378,
    1379,
    1375,
    1352,
    1362,
    1377,
    1379,
    1375,
    1343,
    1378,
    1410,
    1386,
    1345,
    1371,
    1174,
    1369,
    1342,
    1379,
    1387,
    1379,
    1373,
    1364,
    1374,
    1375,
    1367,
    1365,
    1271,
    1268,
    1288,
    1165,
    1023,
    1399,
    1213,
    1384,
    1376,
    1377,
    1356,
    1389,
    1247,
    1149,
    1369,
    1390,
    1389,
    1354,
    1396,
    1356,
    1400,
    1364,
    1345,
    1388,
    1394,
    1380,
    1343,
    1378,
    1393,
    1060,
    1037,
    1267,
    1048,
    1303,
    1298,
    1324,
    1397,
    1370,
    1361,
    1422,
    1252,
    1255,
    1260,
    1252,
    1274,
    1270,
    1282,
    1263,
    1269,
    1273,
    1272,
    1276,
    1272,
    1187,
    1065,
    1282,
    1268,
    1053,
    2335,
    2527,
    1123,
    1271,
    1275,
    1293,
    1292,
    1268,
    1057,
    1274,
    1297,
    1269,
    1276,
    1273,
    1285,
    1273,
    1273,
    1275,
    1293,
    1264,
    1272,
    1277,
    1276,
    1275,
    1150,
    1254,
    1267,
    1278,
    1270,
    1276,
    1267,
    2310,
    1271,
    1272,
    1286,
    1265,
    1238,
    1079,
    2272,
    1135,
    1251,
    1257,
    1286,
    1276,
    1264,
    1281,
    1258,
    1268,
    1272,
    1064,
    1272,
    1047,
    1092,
    1265,
    1271,
    1269,
    1272,
    1269,
    1285,
    1255,
    2564,
    1263,
    1272,
    1275,
    2547,
    1274,
    1273,
    1275,
    1275,
    1193,
    1272,
    1274,
    1272,
    1289,
    1273,
    1275,
    1274,
    1280,
    2416,
    1267,
    1266,
    1283,
    1270,
    1276,
    1290,
    1258,
    1286,
    1275,
    1273,
    1278,
    1272,
    1283,
    1389,
    1182,
    1263,
    1276,
    1275,
    1271,
    1269,
    1273,
    1169,
    1131,
    1276,
    1268,
    1068,
    1250,
    1271,
    2485,
    2546,
    1186,
    1258,
    1295,
    1309,
    1257,
    1278,
    1273,
    1275,
    2541,
    1272,
    1271,
    1128,
    1274,
    1299,
    1273,
    1271,
    1275,
    1274,
    1283,
    1268,
    1273,
    1299,
    1290,
    1110,
    1251,
    1277,
    1274,
    1278,
    1275,
    1272,
    1270,
    1281,
    1270,
    1278,
    1272,
    1275,
    1272,
    1279,
    1288,
    1264,
    1274,
    1310,
    1287,
    2566,
    1119,
    1288,
    1174,
    1118,
    1204,
    1254,
    1273,
    1148,
    1278,
    1274,
    1269,
    1122,
    1266,
    1277,
    1272,
    1277,
    1294,
    1276,
    1320,
    1257,
    1285,
    1263,
    1152,
    1275,
    1272,
    1272,
    1271,
    1285,
    1280,
    1286,
    1282,
    1280,
    1292,
    1269,
    1271,
    1288,
    1270,
    1268,
    1276,
    1267,
    1281,
    1261,
    1267,
    1284,
    1270,
    1275,
    1273,
    1277,
    1295,
    1288,
    1281,
    1288,
    2544,
    1279,
    1280,
    1271,
    2532,
    1303,
    1231,
    1276,
    1298,
    1254,
    1271,
    1269,
    1274,
    1281,
    1266,
    1260,
    1267,
    1125,
    1273,
    1151,
    1277,
    1270,
    1287,
    1273,
    1293,
    1277,
    1272,
    1276,
    1276,
    1277,
    1278,
    1268,
    1275,
    1275,
    1274,
    1276,
    1294,
    1296,
    1254,
    2549,
    1118,
    1292,
    1278,
    1262,
    1270,
    1192,
    1051,
    1094,
    1286,
    1261,
    1278,
    1271,
    1274,
    1189,
    2568,
    1160,
    1270,
    1175,
    1045,
    1266,
    1283,
    2511,
    1265,
    1263,
    1264,
    1104,
    1076,
    1278,
    1280,
    1277,
    1276,
    1266,
    1280,
    1280,
    2541,
    1272,
    1263,
    1289,
    1258,
    1247,
    1134,
    2288,
    1295,
    1272,
    1276,
    1272,
    1276,
    1273,
    1274,
    1275,
    1118,
    1269,
    1294,
    1268,
    1278,
    1272,
    1277,
    1274,
    1281,
    1270,
    1273,
    1277,
    1283,
    1311,
    1282,
    1276,
    1285,
    1286,
    1294,
    1254,
    1274,
    1263,
    1267,
    1272,
    1270,
    1288,
    1267,
    1279,
    1282,
    1275,
    1278,
    1255,
    1269,
    1285,
    1254,
    1268,
    1271,
    1280,
    1289,
    1231,
    1280,
    1273,
    2548,
    1274,
    1087,
    1268,
    1267,
    1275,
    1289,
    1260,
    1264,
    1289,
    1257,
    1275,
    1149,
    1271,
    1274,
    1274,
    1275,
    1273,
    1276,
    1273,
    1063,
    1290,
    1257,
    1292,
    1295,
    1257,
    1273,
    1277,
    1272,
    1277,
    1280,
    1291,
    1098,
    1277,
    1265,
    1279,
    1271,
    1268,
    1231,
    1269,
    1272,
    1271,
    1278,
    1268,
    2551,
    2547,
    1276,
    1144,
    1293,
    1291,
    1299,
    1274,
    1284,
    1270,
    1267,
    1276,
    1272,
    1269,
    2544,
    1286,
    1275,
    1287,
    1173,
    1278,
    1273,
    1275,
    1312,
    1271,
    1254,
    1304,
    1255,
    1267,
    1273,
    1274,
    1276,
    1297,
    1257,
    1272,
    1274,
    1042,
    1270,
    1310,
    1291,
    1282,
    1282,
    1045,
    1273,
    1276,
    1271,
    1276,
    1069,
    1275,
    1292,
    1275,
    1271,
    1276,
    1275,
    1275,
    1275,
    1273,
    1288,
    1268,
    1283,
    1286,
    1265,
    1271,
    1273,
    1275,
    1259,
    1276,
    1093,
    1281,
    1259,
    1285,
    1291,
    1273,
    1181,
    1277,
    1269,
    1277,
    1270,
    1275,
    1272,
    1276,
    1272,
    1294,
    1278,
    1292,
    1266,
    1260,
    1279,
    1274,
    1276,
    1273,
    1275,
    1272,
    1273,
    1269,
    1267,
    1274,
    1279,
    1095,
    2522,
    1275,
    1269,
    2540,
    1281,
    1254,
    1274,
    1286,
    1257,
    1211,
    1260,
    1284,
    1198,
    1234,
    1289,
    1271,
    1259,
    1274,
    1275,
    1203,
    1275,
    1155,
    1302,
    1272,
    2534,
    2550,
    2556,
    1039,
    1271,
    1281,
    1274,
    1287,
    1281,
    1036,
    1271,
    1272,
    1268,
    1273,
    1291,
    1280,
    1275,
    1277,
    1294,
    1256,
    1274,
    1277,
    1273,
    2430,
    1262,
    1024,
    1224,
    1267,
    1275,
    1273,
    1277,
    1272,
    1278,
    1272,
    1276,
    1289,
    1286,
    1269,
    1277,
    2546,
    1272,
    2365,
    1275,
    1272,
    1294,
    1271,
    1277,
    1273,
    1277,
    1274,
    1277,
    1273,
    1275,
    1296,
    1250,
    1274,
    1276,
    1274,
    1277,
    1273,
    1277,
    1273,
    1213,
    1281,
    1274,
    1269,
    2515,
    1277,
    1271,
    1276,
    1276,
    1273,
    1155,
    1278,
    1270,
    1282,
    1274,
    1273,
    1242,
    1293,
    1249,
    1269,
    1261,
    1280,
    1275,
    1276,
    1271,
    1034,
    1268,
    1279,
    1268,
    1288,
    1195,
    1274,
    1274,
    1201,
    1274,
    1268,
    1293,
    1277,
    1157,
    1286,
    1279,
    1193,
    1263,
    1272,
    1278,
    1274,
    1281,
    1230,
    1271,
    1273,
    1275,
    1287,
    1277,
    1291,
    1260,
    1274,
    1272,
    1276,
    1294,
    1254,
    2571,
    1010,
    1272,
    1277,
    1273,
    1275,
    1274,
    1166,
    1273,
    1278,
    1129,
    1107,
    1218,
    1266,
    1271,
    1138,
    1275,
    1266,
    1282,
    1258,
    1294,
    1305,
    1260,
    1269,
    1276,
    1274,
    1137,
    1298,
    1213,
    1275,
    1274,
    1270,
    1228,
    1275,
    1274,
    1275,
    1126,
    1274,
    1272,
    1297,
    1274,
    1264,
    1270,
    1277,
    1395,
    1376,
    1344,
    1377,
    1373,
    1376,
    1356,
    1376,
    1390,
    1392,
    1344,
    1375,
    1377,
    1378,
    1356,
    1376,
    1388,
    1402,
    1256,
    1273,
    1219,
    1016,
    1393,
    1191,
    1375,
    1347,
    1360,
    1355,
    1378,
    1389,
    1372,
    1343,
    1394,
    1378,
    1385,
    1350,
    1363,
    1182,
    1395,
    1244,
    1362,
    1355,
    1388,
    1384,
    1378,
    1267,
    1267,
    1274,
    1435,
    1374,
    1098,
    1364,
    1362,
    1379,
    1379,
    1359,
    1364,
    1377,
    1182,
    1358,
    1378,
    1053,
    1357,
    1321,
    1359,
    1372,
    1379,
    1386,
    1342,
    1377,
    1408,
    1259,
    1273,
    1232,
    1027,
    1397,
    1327,
    1398,
    1377,
    1385,
    1343,
    1378,
    1376,
    1378,
    1343,
    1337,
    1363,
    1358,
    1417,
    1358,
    1422,
    1374,
    1364,
    1355,
    1375,
    1339,
    1391,
    1380,
    1375,
    1377,
    1371,
    1372,
    1350,
    1369,
    1361,
    1326,
    1377,
    1380,
    1392,
    1256,
    1391,
    1342,
    1377,
    1374,
    1271,
    1404,
    1371,
    1383,
    1381,
    1351,
    1364,
    1348,
    1175,
    1235,
    1249,
    1055,
    1279,
    1327,
    1326,
    1410,
    1357,
    1378,
    1387,
    1386,
    1387,
    1379,
    1355,
    1133,
    1365,
    1379,
    1183,
    1365,
    1376,
    1376,
    1378,
    1174,
    1381,
    1376,
    1380,
    1269,
    1371,
    1364,
    1380,
    1377,
    1354,
    1376,
    1376,
    1376,
    1339,
    1399,
    1377,
    1376,
    1355,
    1390,
    1379,
    1379,
    1356,
    1375,
    1390,
    1378,
    1354,
    1379,
    1380,
    1387,
    1260,
    1287,
    1245,
    1284,
    1397,
    1396,
    1392,
    1368,
    1247,
    1406,
    1363,
    1358,
    1366,
    1271,
    1366,
    1389,
    1345,
    1378,
    1387,
    1392,
    1151,
    1402,
    1376,
    1377,
    1360,
    1358,
    1378,
    1376,
    1356,
    1392,
    1371,
    1396,
    1358,
    1383,
    1355,
    1343,
    1399,
    1360,
    1350,
    1375,
    1357,
    1339,
    1357,
    1378,
    1386,
    1375,
    1143,
    1391,
    1344,
    1378,
    1377,
    1391,
    1275,
    1274,
    1120,
    1282,
    1391,
    1341,
    1377,
    1374,
    1089,
    1326,
    1373,
    1393,
    1388,
    1416,
    1365,
    1369,
    1367,
    1360,
    1369,
    1386,
    1377,
    1377,
    1178,
    1376,
    1357,
    1362,
    1342,
    1389,
    1387,
    1378,
    1099,
    1376,
    1382,
    1360,
    1352,
    1368,
    1365,
    1371,
    1345,
    1356,
    1365,
    1360,
    1358,
    1361,
    1348,
    1396,
    1355,
    1380,
    1379,
    1380,
    1322,
    1397,
    1258,
    1281,
    1272,
    1274,
    1406,
    1357,
    1339,
    1302,
    1378,
    1280,
    1380,
    1303,
    1380,
    1321,
    1400,
    1224,
    1360,
    1305,
    1364,
    1366,
    1346,
    1379,
    1358,
    1378,
    1371,
    1390,
    1372,
    1377,
    1254,
    1278,
    1263,
    1279,
    1273,
    1291,
    1283,
    1268,
    1273,
    1269,
    1269,
    1269,
    1284,
    1281,
    1269,
    1269,
    1273,
    1273,
    1275,
    1277,
    1274,
    1289,
    1347,
    1235,
    1356,
    1354,
    1267,
    1277,
    1274,
    1276,
    1132,
    1341,
    1257,
    1287,
    1070,
    1290,
    1264,
    1268,
    1268,
    1127,
    1174,
    1171,
    1284,
    1271,
    1310,
    994,
    1290,
    1270,
    1269,
    1144,
    1150,
    1099,
    1033,
    1093,
    1035,
    1245,
    1037,
    1288,
    1107,
    1107,
    1014,
    1120,
    1124,
    1284,
    1267,
    1268,
    1275,
    1164,
    1285,
    1271,
    1024,
    1155,
    1209,
    1320,
    1327,
    1399,
    1358,
    1367,
    1378,
    1055,
    1364,
    1378,
    1099,
    1267,
    1275,
    1214,
    1288,
    1403,
    1379,
    1354,
    1375,
    1278,
    1383,
    1357,
    1376,
    1390,
    1358,
    1369,
    1392,
    1380,
    1395,
    1199,
    1391,
    1355,
    1367,
    1038,
    1384,
    1119,
    1363,
    1377,
    1295,
    1399,
    1306,
    1375,
    1388,
    1390,
    1374,
    1356,
    1041,
    1319,
    1263,
    1223,
    1282,
    1280,
    1273,
    1271,
    1273,
    1272,
    1190,
    1289,
    1271,
    1263,
    1256,
    1288,
    1272,
    1280,
    1268,
    1264,
    1225,
    1006,
    1074,
    1258,
    1114,
    1285,
    1266,
    1267,
    1430,
    1310,
    1392,
    1204,
    1032,
    1260,
    1271,
    1274,
    1274,
    1119,
    1319,
    1311,
    1174,
    1393,
    1341,
    1378,
    1376,
    1355,
    1377,
    1379,
    1377,
    1355,
    1377,
    1359,
    1367,
    1393,
    1364,
    1351,
    1375,
    1378,
    1376,
    1355,
    1378,
    1383,
    1356,
    1370,
    1353,
    1369,
    1012,
    1391,
    1375,
    1378,
    1149,
    1359,
    1185,
    1272,
    1284,
    1289,
    1260,
    1391,
    1356,
    1307,
    1297,
    1357,
    1322,
    1083,
    1275,
    1270,
    1261,
    1282,
    1270,
    1032,
    1289,
    1304,
    1296,
    1397,
    1377,
    1101,
    1346,
    1405,
    1362,
    1353,
    1378,
    1387,
    1386,
    1279,
    1039,
    1263,
    1283,
    1360,
    1358,
    1378,
    1386,
    1389,
    1355,
    1365,
    1377,
    1376,
    1356,
    1387,
    1345,
    1347,
    1386,
    1379,
    1379,
    1356,
    1115,
    1378,
    1189,
    1273,
    1282,
    1091,
    1210,
    1400,
    1378,
    1355,
    1377,
    1154,
    1259,
    1440,
    1381,
    1379,
    1378,
    1070,
    1338,
    1332,
    1289,
    1354,
    1208,
    1126,
    1117,
    1267,
    1276,
    1281,
    1086,
    1292,
    1292,
    1325,
    1392,
    1336,
    1379,
    1355,
    1362,
    1375,
    1376,
    1345,
    1374,
    1377,
    1383,
    1361,
    1386,
    1378,
    1373,
    1359,
    1378,
    1389,
    1377,
    1321,
    1354,
    1354,
    1367,
    1287,
    1278,
    1272,
    1275,
    1303,
    1379,
    1343,
    1376,
    1378,
    1377,
    1355,
    1388,
    1314,
    1389,
    1344,
    1278,
    1392,
    1377,
    1354,
    1379,
    1378,
    1376,
    1354,
    1377,
    1394,
    1379,
    1321,
    1377,
    1387,
    1376,
    1354,
    1378,
    1210,
    1432,
    1312,
    1374,
    1358,
    1388,
    1337,
    1358,
    1403,
    1377,
    1354,
    1364,
    1111,
    1114,
    1268,
    1398,
    1378,
    1388,
    1354,
    1190,
    1251,
    1274,
    1281,
    1273,
    1269,
    1259,
    1276,
    1271,
    1281,
    1269,
    1270,
    1268,
    1063,
    1292,
    1273,
    1279,
    1267,
    1092,
    1284,
    1280,
    1280,
    1259,
    1285,
    1266,
    1269,
    1269,
    1115,
    1259,
    1282,
    1076,
    1283,
    1038,
    1276,
    1276,
    1281,
    1307,
    1288,
    1401,
    1391,
    1379,
    1350,
    1389,
    1373,
    1357,
    1353,
    1346,
    1357,
    1378,
    1377,
    1376,
    1355,
    1325,
    1378,
    1387,
    1347,
    1246,
    1273,
    1277,
    1279,
    1307,
    1378,
    1355,
    1056,
    1392,
    1062,
    1400,
    1356,
    1335,
    1358,
    1145,
    1368,
    1360,
    1198,
    1367,
    1377,
    1389,
    1368,
    1387,
    1345,
    1390,
    1375,
    1404,
    1354,
    1362,
    1390,
    1361,
    1357,
    1367,
    1395,
    1352,
    1365,
    1377,
    1378,
    1386,
    1356,
    1369,
    1377,
    1385,
    1359,
    1336,
    1078,
    1110,
    1268,
    1372,
    2474,
    1276,
    1267,
    1293,
    1036,
    1270,
    1274,
    1286,
    1274,
    1274,
    1290,
    1269,
    1280,
    1272,
    1084,
    1247,
    1272,
    1279,
    1239,
    1281,
    1253,
    2423,
    1210,
    1246,
    1259,
    2547,
    1030,
    1260,
    1177,
    2181,
    1140,
    1270,
    1032,
    1083,
    1272,
    1281,
    1233,
    1252,
    1289,
    1216,
    1019,
    1247,
    2539,
    1062,
    1179,
    1267,
    1251,
    1049,
    1020,
    1033,
    2314,
    1035,
    1252,
    2509,
    1040,
    1277,
    1165,
    1149,
    1275,
    2396,
    1278,
    1271,
    1277,
    1273,
    1289,
    1270,
    1275,
    1265,
    1274,
    1268,
    1271,
    1284,
    1289,
    1281,
    1240,
    1269,
    1271,
    1268,
    1270,
    1271,
    1272,
    1270,
    1273,
    1072,
    1269,
    1290,
    1260,
    1288,
    1277,
    1273,
    1271,
    1124,
    1289,
    1276,
    1273,
    1279,
    1114,
    1276,
    1291,
    1203,
    1272,
    1280,
    1270,
    1280,
    1269,
    1273,
    1276,
    1293,
    1278,
    1199,
    1279,
    1038,
    2577,
    1296,
    1266,
    1304,
    1065,
    1256,
    1272,
    1270,
    1294,
    1272,
    2522,
    1275,
    1165,
    1278,
    1269,
    1241,
    1271,
    1276,
    1273,
    1277,
    1264,
    1284,
    1260,
    1091,
    2542,
    1272,
    1272,
    1277,
    1275,
    1276,
    1091,
    1277,
    1272,
    1280,
    1271,
    1272,
    1123,
    1272,
    1234,
    1273,
    1276,
    1273,
    1275,
    1271,
    1276,
    1274,
    1095,
    1276,
    1272,
    1275,
    1278,
    1272,
    2405,
    1172,
    1264,
    1280,
    1274,
    1271,
    1277,
    1272,
    1047,
    1286,
    1274,
    1060,
    1275,
    1060,
    1276,
    1275,
    2547,
    1288,
    1270,
    1276,
    1295,
    1278,
    1298,
    1269,
    1317,
    1166,
    1280,
    1257,
    1271,
    1274,
    1270,
    1277,
    1138,
    1255,
    1285,
    1272,
    1284,
    1260,
    1286,
    1277,
    1274,
    1274,
    1275,
    1274,
    1302,
    1263,
    1274,
    2545,
    1275,
    1273,
    1295,
    1274,
    1279,
    1067,
    1012,
    1266,
    1271,
    1267,
    1279,
    1248,
    1269,
    1289,
    1153,
    1276,
    1050,
    1272,
    1029,
    1270,
    1274,
    1277,
    1271,
    1277,
    1273,
    1276,
    1285,
    1025,
    1274,
    1296,
    1271,
    1277,
    2548,
    1274,
    1271,
    1277,
    1273,
    1129,
    1273,
    1284,
    1263,
    1285,
    2569,
    1259,
    1289,
    1260,
    1274,
    1277,
    1291,
    1277,
    1272,
    1151,
    1272,
    1284,
    1267,
    2334,
    1292,
    1271,
    1289,
    1084,
    1204,
    1113,
    1273,
    1276,
    1284,
    1193,
    1034,
    1095,
    1026,
    1268,
    1265,
    1231,
    1273,
    1271,
    1273,
    1271,
    1273,
    1267,
    1272,
    1271,
    1291,
    1268,
    1272,
    1267,
    1289,
    2435,
    2547,
    2557,
    1273,
    1264,
    1276,
    1272,
    1207,
    1270,
    1268,
    1272,
    1284,
    1271,
    1331,
    1247,
    1293,
    1279,
    1281,
    1277,
    1269,
    1262,
    1095,
    1268,
    1271,
    1273,
    1273,
    1276,
    1148,
    1259,
    1276,
    1235,
    1291,
    1251,
    1285,
    1251,
    1271,
    1268,
    1274,
    1267,
    1275,
    1347,
    1273,
    1034,
    1275,
    1277,
    1220,
    1293,
    1260,
    1275,
    1269,
    1271,
    1268,
    1273,
    1271,
    1268,
    1277,
    1265,
    1279,
    1271,
    1272,
    1277,
    1273,
    1279,
    1281,
    1288,
    1271,
    1310,
    2550,
    1273,
    1273,
    1283,
    1271,
    1275,
    1268,
    1276,
    1272,
    1277,
    1271,
    1298,
    1272,
    1297,
    1217,
    1258,
    1098,
    1273,
    1274,
    3816,
    1272,
    1267,
    1296,
    1244,
    1268,
    1273,
    1274,
    1293,
    1271,
    1274,
    1277,
    2544,
    1275,
    1273,
    1275,
    1131,
    1275,
    1270,
    1279,
    1285,
    1263,
    1308,
    1267,
    1058,
    1274,
    1270,
    1276,
    1269,
    1289,
    1279,
    1186,
    1273,
    1273,
    1264,
    2556,
    1270,
    1291,
    1277,
    1274,
    1290,
    1275,
    1270,
    1275,
    1272,
    1273,
    1029,
    1268,
    1271,
    1267,
    1277,
    1288,
    1181,
    1268,
    1275,
    1098,
    1267,
    1290,
    1265,
    1272,
    1280,
    1274,
    1266,
    1270,
    1271,
    1272,
    1269,
    1267,
    1201,
    1275,
    1269,
    1275,
    1273,
    1287,
    1271,
    1276,
    1273,
    1277,
    1272,
    1276,
    1291,
    1295,
    1273,
    1275,
    1275,
    1278,
    1272,
    1292,
    1270,
    1279,
    1270,
    1274,
    1273,
    1276,
    1275,
    1276,
    2544,
    1276,
    2491,
    2531,
    1268,
    1251,
    1271,
    1268,
    1173,
    1263,
    1285,
    1274,
    1299,
    1269,
    1273,
    1277,
    1261,
    1272,
    1276,
    1271,
    2573,
    1292,
    1291,
    1273,
    1276,
    1290,
    1274,
    2327,
    2542,
    1276,
    1277,
    1291,
    1253,
    1273,
    1088,
    1276,
    1272,
    1275,
    2536,
    1278,
    1271,
    1093,
    1276,
    1273,
    1276,
    1286,
    1262,
    1285,
    1263,
    1080,
    1277,
    1272,
    1107,
    1271,
    1276,
    1013,
    1283,
    1097,
    1276,
    1272,
    1095,
    1163,
    1273,
    1268,
    1272,
    1269,
    2540,
    1275,
    1291,
    1263,
    1301,
    1238,
    2548,
    1272,
    1274,
    1273,
    1272,
    1277,
    1270,
    1276,
    1284,
    1279,
    1288,
    2347,
    1276,
    1275,
    1273,
    1280,
    2556,
    1276,
    1273,
    1279,
    1275,
    1275,
    1272,
    1295,
    1255,
    1274,
    1278,
    1273,
    1273,
    1281,
    1271,
    1296,
    1287,
    2321,
    1061,
    1270,
    1277,
    1283,
    1297,
    1271,
    1301,
    1261,
    1273,
    1275,
    1047,
    2550,
    1195,
    1289,
    1274,
    1274,
    1277,
    1272,
    1276,
    1273,
    1295,
    1274,
    1276,
    1274,
    1275,
    1274,
    1277,
    1272,
    1289,
    1260,
    1271,
    1276,
    1282,
    1172,
    1274,
    1277,
    1271,
    1277,
    1276,
    1272,
    1275,
    1079,
    1273,
    1278,
    3614,
    1277,
    1271,
    1276,
    1276,
    1289,
    1261,
    1287,
    1261,
    1270,
    1087,
    1289,
    1276,
    1268,
    1276,
    1275,
    1266,
    1269,
    1273,
    1269,
    1274,
    1288,
    1276,
    1294,
    1277,
    1272,
    1276,
    1279,
    1270,
    1274,
    1272,
    1278,
    1120,
    1291,
    1295,
    1305,
    1254,
    1285,
    1257,
    1273,
    1276,
    1270,
    1275,
    1269,
    1277,
    1274,
    1301,
    1256,
    1296,
    1255,
    1274,
    1296,
    1381,
    1371,
    1344,
    1373,
    1379,
    1353,
    1356,
    1406,
    1056,
    1260,
    1274,
    1193,
    1060,
    1385,
    1388,
    1385,
    1355,
    1157,
    1373,
    1286,
    1358,
    1380,
    1358,
    1378,
    1379,
    1400,
    1351,
    1363,
    1375,
    1390,
    1376,
    1270,
    1404,
    1048,
    1399,
    1356,
    1307,
    1383,
    1376,
    1378,
    1355,
    1375,
    1376,
    1382,
    1369,
    1387,
    1378,
    1376,
    1344,
    1380,
    1376,
    1377,
    1355,
    1361,
    1377,
    1390,
    1385,
    1352,
    1346,
    1377,
    1382,
    1285,
    1266,
    1281,
    1288,
    998,
    1051,
    1408,
    1280,
    1357,
    1378,
    1389,
    1389,
    1302,
    1353,
    1379,
    1375,
    1367,
    1364,
    1388,
    1389,
    1299,
    1361,
    1364,
    1391,
    1387,
    1361,
    1379,
    1377,
    1379,
    1332,
    1373,
    1350,
    1172,
    1381,
    1308,
    1339,
    1380,
    1386,
    1384,
    1337,
    1390,
    1376,
    1379,
    1343,
    1376,
    1385,
    1184,
    1386,
    1366,
    1387,
    1349,
    1359,
    1270,
    1275,
    1232,
    1276,
    1405,
    1011,
    1371,
    1155,
    1334,
    1373,
    1256,
    1391,
    1377,
    1376,
    1175,
    1372,
    1375,
    1391,
    1382,
    1308,
    1375,
    1360,
    1378,
    1343,
    1393,
    1342,
    1376,
    1375,
    1380,
    1342,
    1174,
    1372,
    1280,
    1346,
    1374,
    1376,
    1376,
    1343,
    1378,
    1378,
    1378,
    1294,
    1391,
    1343,
    1331,
    1399,
    1381,
    1355,
    1372,
    1377,
    1377,
    1358,
    1240,
    1266,
    1274,
    1276,
    1275,
    1399,
    1356,
    1343,
    1387,
    1379,
    1377,
    1356,
    1390,
    1392,
    1353,
    1054,
    1392,
    1217,
    1378,
    1374,
    1310,
    1357,
    1261,
    1397,
    1355,
    1378,
    1378,
    1377,
    1378,
    1368,
    1305,
    1083,
    1355,
    1396,
    1374,
    1378,
    1358,
    1379,
    1391,
    1371,
    1308,
    1388,
    1381,
    1357,
    1364,
    1357,
    1301,
    1365,
    1359,
    1407,
    1358,
    1370,
    1370,
    1233,
    1157,
    1275,
    1054,
    1398,
    1387,
    1354,
    1368,
    1390,
    1378,
    1353,
    1365,
    1244,
    1388,
    1357,
    1283,
    1389,
    1380,
    1330,
    1394,
    1377,
    1387,
    1343,
    1379,
    1377,
    1356,
    1274,
    1388,
    1025,
    1343,
    1379,
    1374,
    1341,
    1353,
    1374,
    1376,
    1379,
    1309,
    1266,
    1377,
    1379,
    1393,
    1378,
    1359,
    1376,
    1387,
    1376,
    1354,
    1378,
    1377,
    1387,
    1345,
    1272,
    1273,
    1277,
    1297,
    1387,
    1379,
    1377,
    1344,
    1379,
    1422,
    1373,
    1363,
    1402,
    1378,
    1285,
    1380,
    1151,
    1358,
    1361,
    1392,
    1387,
    1371,
    1365,
    1380,
    1355,
    1386,
    1404,
    1382,
    1358,
    1367,
    1380,
    1376,
    1357,
    1363,
    1358,
    1379,
    1375,
    1388,
    1352,
    1386,
    1387,
    1378,
    1358,
    1374,
    1376,
    1386,
    1343,
    1387,
    1377,
    1386,
    1356,
    1246,
    1282,
    1200,
    1279,
    1394,
    1286,
    1354,
    1160,
    1358,
    1395,
    1384,
    1355,
    1154,
    1402,
    1341,
    1353,
    1379,
    1376,
    1356,
    1380,
    1363,
    1368,
    1342,
    1377,
    1394,
    1378,
    1355,
    1393,
    1386,
    1386,
    1355,
    1364,
    1376,
    1378,
    1153,
    1388,
    1358,
    1368,
    1345,
    1346,
    1362,
    1384,
    1377,
    1367,
    1360,
    1342,
    1354,
    1376,
    1366,
    1357,
    1366,
    1370,
    1266,
    1276,
    1276,
    1289,
    1393,
    1354,
    1372,
    1376,
    1270,
    1360,
    1403,
    1378,
    1281,
    1391,
    1376,
    1374,
    1344,
    1405,
    1379,
    1337,
    1359,
    1390,
    1297,
    1360,
    1375,
    1393,
    1378,
    1373,
    1355,
    1379,
    1377,
    1343,
    1385,
    1365,
    1379,
    1356,
    1270,
    1282,
    1359,
    1380,
    1375,
    1385,
    1345,
    1378,
    1388,
    1377,
    1369,
    1370,
    1368,
    1371,
    1371,
    1369,
    1258,
    1276,
    1275,
    1279,
    1304,
    1362,
    1378,
    1134,
    1369,
    1378,
    1351,
    1150,
    1377,
    1375,
    1388,
    1347,
    1365,
    1366,
    1389,
    1384,
    1370,
    1380,
    1378,
    1379,
    1357,
    1379,
    1379,
    1174,
    1355,
    1379,
    1378,
    1379,
    1354,
    1377,
    1380,
    1386,
    1355,
    1378,
    1390,
    1380,
    1370,
    1375,
    1355,
    1389,
    1390,
    1380,
    1344,
    1389,
    1256,
    1356,
    1392,
    1373,
    1112,
    1271,
    1283,
    1029,
    1197,
    1315,
    1291,
    1263,
    1294,
    1295,
    1295,
    1280,
    1097,
    1247,
    1284,
    1303,
    1166,
    1288,
    1155,
    1287,
    1287,
    1289,
    1260,
    1299,
    1201,
    1284,
    1231,
    1286,
    1159,
    1297,
    1281,
    1295,
    1256,
    1287,
    1216,
    1285,
    1216,
    1284,
    1217,
    1227,
    1276,
    1285,
    1218,
    1289,
    1286,
    1284,
    1285,
    1284,
    1283,
    1263,
    1282,
    1218,
    1285,
    1027,
    1108
  ],
  "scripts": [
    {
      "id": "0",
      "url": "",
      "pkgUrl": "(system)"
    },
    {
      "id": "29",
      "url": "timers.js",
      "source": "(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst async_wrap = process.binding('async_wrap');\nconst TimerWrap = process.binding('timer_wrap').Timer;\nconst L = require('internal/linkedlist');\nconst internalUtil = require('internal/util');\nconst { createPromise, promiseResolve } = process.binding('util');\nconst async_hooks = require('async_hooks');\nconst assert = require('assert');\nconst util = require('util');\nconst debug = util.debuglog('timer');\nconst kOnTimeout = TimerWrap.kOnTimeout | 0;\nconst initTriggerId = async_hooks.initTriggerId;\n// Two arrays that share state between C++ and JS.\nconst { async_hook_fields, async_uid_fields } = async_wrap;\n// Used to change the state of the async id stack.\nconst { pushAsyncIds, popAsyncIds } = async_wrap;\n// The needed emit*() functions.\nconst { emitInit, emitBefore, emitAfter, emitDestroy } = async_hooks;\n// Grab the constants necessary for working with internal arrays.\nconst { kInit, kBefore, kAfter, kDestroy, kAsyncUidCntr } =\n    async_wrap.constants;\n// Symbols for storing async id state.\nconst async_id_symbol = Symbol('asyncId');\nconst trigger_id_symbol = Symbol('triggerId');\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nconst TIMEOUT_MAX = 2147483647; // 2^31-1\n\n\n// HOW and WHY the timers implementation works the way it does.\n//\n// Timers are crucial to Node.js. Internally, any TCP I/O connection creates a\n// timer so that we can time out of connections. Additionally, many user\n// libraries and applications also use timers. As such there may be a\n// significantly large amount of timeouts scheduled at any given time.\n// Therefore, it is very important that the timers implementation is performant\n// and efficient.\n//\n// Note: It is suggested you first read though the lib/internal/linkedlist.js\n// linked list implementation, since timers depend on it extensively. It can be\n// somewhat counter-intuitive at first, as it is not actually a class. Instead,\n// it is a set of helpers that operate on an existing object.\n//\n// In order to be as performant as possible, the architecture and data\n// structures are designed so that they are optimized to handle the following\n// use cases as efficiently as possible:\n\n// - Adding a new timer. (insert)\n// - Removing an existing timer. (remove)\n// - Handling a timer timing out. (timeout)\n//\n// Whenever possible, the implementation tries to make the complexity of these\n// operations as close to constant-time as possible.\n// (So that performance is not impacted by the number of scheduled timers.)\n//\n// Object maps are kept which contain linked lists keyed by their duration in\n// milliseconds.\n// The linked lists within also have some meta-properties, one of which is a\n// TimerWrap C++ handle, which makes the call after the duration to process the\n// list it is attached to.\n//\n//\n//  > Object Map\n// \n// \n//  refedLists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n//           \n//              \n//           \n//  TimersList { _idleNext: { }, _idlePrev: (self), _timer: (TimerWrap) }\n//          \n//                                     ^\n//         { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }\n//           \n//                                             ^\n//           { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }\n//   \n//     \n//      >  Actual JavaScript timeouts\n// \n//  > Linked List\n//\n//\n// With this, virtually constant-time insertion (append), removal, and timeout\n// is possible in the JavaScript layer. Any one list of timers is able to be\n// sorted by just appending to it because all timers within share the same\n// duration. Therefore, any timer added later will always have been scheduled to\n// timeout later, thus only needing to be appended.\n// Removal from an object-property linked list is also virtually constant-time\n// as can be seen in the lib/internal/linkedlist.js implementation.\n// Timeouts only need to process any timers due to currently timeout, which will\n// always be at the beginning of the list for reasons stated above. Any timers\n// after the first one encountered that does not yet need to timeout will also\n// always be due to timeout at a later time.\n//\n// Less-than constant time operations are thus contained in two places:\n// TimerWrap's backing libuv timers implementation (a performant heap-based\n// queue), and the object map lookup of a specific list by the duration of\n// timers within (or creation of a new list).\n// However, these operations combined have shown to be trivial in comparison to\n// other alternative timers architectures.\n\n\n// Object maps containing linked lists of timers, keyed and sorted by their\n// duration in milliseconds.\n//\n// The difference between these two objects is that the former contains timers\n// that will keep the process open if they are the only thing left, while the\n// latter will not.\n//\n// - key = time in milliseconds\n// - value = linked list\nconst refedLists = Object.create(null);\nconst unrefedLists = Object.create(null);\n\n\n// Schedule or re-schedule a timer.\n// The item must have been enroll()'d first.\nconst active = exports.active = function(item) {\n  insert(item, false);\n};\n\n// Internal APIs that need timeouts should use `_unrefActive()` instead of\n// `active()` so that they do not unnecessarily keep the process open.\nexports._unrefActive = function(item) {\n  insert(item, true);\n};\n\n\nfunction timerEmitBefore(asyncId, triggerId) {\n  if (async_hook_fields[kBefore] > 0)\n    emitBefore(asyncId, triggerId);\n  else\n    pushAsyncIds(asyncId, triggerId);\n}\n\n\nfunction timerEmitAfter(asyncId) {\n  if (async_hook_fields[kAfter] > 0)\n    emitAfter(asyncId);\n  else\n    popAsyncIds(asyncId);\n}\n\n\n// The underlying logic for scheduling or re-scheduling a timer.\n//\n// Appends a timer onto the end of an existing timers list, or creates a new\n// TimerWrap backed list if one does not already exist for the specified timeout\n// duration.\nfunction insert(item, unrefed) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === undefined) return;\n\n  item._idleStart = TimerWrap.now();\n\n  const lists = unrefed === true ? unrefedLists : refedLists;\n\n  // Use an existing list if there is one, otherwise we need to make a new one.\n  var list = lists[msecs];\n  if (!list) {\n    debug('no %d list was found in insert, creating a new one', msecs);\n    lists[msecs] = list = createTimersList(msecs, unrefed);\n  }\n\n  if (!item[async_id_symbol] || item._destroyed) {\n    item._destroyed = false;\n    item[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n    item[trigger_id_symbol] = initTriggerId();\n    if (async_hook_fields[kInit] > 0)\n      emitInit(item[async_id_symbol], 'Timeout', item[trigger_id_symbol], item);\n  }\n\n  L.append(list, item);\n  assert(!L.isEmpty(list)); // list is not empty\n}\n\nfunction createTimersList(msecs, unrefed) {\n  // Make a new linked list of timers, and create a TimerWrap to schedule\n  // processing for the list.\n  const list = new TimersList(msecs, unrefed);\n  L.init(list);\n  list._timer._list = list;\n\n  if (unrefed === true) list._timer.unref();\n  list._timer.start(msecs);\n\n  list._timer[kOnTimeout] = listOnTimeout;\n\n  return list;\n}\n\nfunction TimersList(msecs, unrefed) {\n  this._idleNext = null; // Create the list with the linkedlist properties to\n  this._idlePrev = null; // prevent any unnecessary hidden class changes.\n  this._timer = new TimerWrap();\n  this._unrefed = unrefed;\n  this.msecs = msecs;\n  this.nextTick = false;\n}\n\nfunction listOnTimeout() {\n  var list = this._list;\n  var msecs = list.msecs;\n\n  if (list.nextTick) {\n    list.nextTick = false;\n    process.nextTick(listOnTimeoutNT, list);\n    return;\n  }\n\n  debug('timeout callback %d', msecs);\n\n  var now = TimerWrap.now();\n  debug('now: %d', now);\n\n  var diff, timer;\n  while (timer = L.peek(list)) {\n    diff = now - timer._idleStart;\n\n    // Check if this loop iteration is too early for the next timer.\n    // This happens if there are more timers scheduled for later in the list.\n    if (diff < msecs) {\n      var timeRemaining = msecs - (TimerWrap.now() - timer._idleStart);\n      if (timeRemaining < 0) {\n        timeRemaining = 0;\n      }\n      this.start(timeRemaining);\n      debug('%d list wait because diff is %d', msecs, diff);\n      return;\n    }\n\n    // The actual logic for when a timeout happens.\n\n    L.remove(timer);\n    assert(timer !== L.peek(list));\n\n    if (!timer._onTimeout) {\n      if (async_hook_fields[kDestroy] > 0 && !timer._destroyed &&\n            typeof timer[async_id_symbol] === 'number') {\n        emitDestroy(timer[async_id_symbol]);\n        timer._destroyed = true;\n      }\n      continue;\n    }\n\n    var domain = timer.domain;\n    if (domain) {\n\n      // If the timer callback throws and the\n      // domain or uncaughtException handler ignore the exception,\n      // other timers that expire on this tick should still run.\n      //\n      // https://github.com/nodejs/node-v0.x-archive/issues/2631\n      if (domain._disposed)\n        continue;\n\n      domain.enter();\n    }\n\n    tryOnTimeout(timer, list);\n\n    if (domain)\n      domain.exit();\n  }\n\n  // If `L.peek(list)` returned nothing, the list was either empty or we have\n  // called all of the timer timeouts.\n  // As such, we can remove the list and clean up the TimerWrap C++ handle.\n  debug('%d list empty', msecs);\n  assert(L.isEmpty(list));\n\n  // Either refedLists[msecs] or unrefedLists[msecs] may have been removed and\n  // recreated since the reference to `list` was created. Make sure they're\n  // the same instance of the list before destroying.\n  if (list._unrefed === true && list === unrefedLists[msecs]) {\n    delete unrefedLists[msecs];\n  } else if (list === refedLists[msecs]) {\n    delete refedLists[msecs];\n  }\n\n  // Do not close the underlying handle if its ownership has changed\n  // (e.g it was unrefed in its callback).\n  if (this.owner)\n    return;\n\n  this.close();\n}\n\n\n// An optimization so that the try/finally only de-optimizes (since at least v8\n// 4.7) what is in this smaller function.\nfunction tryOnTimeout(timer, list) {\n  timer._called = true;\n  const timerAsyncId = (typeof timer[async_id_symbol] === 'number') ?\n      timer[async_id_symbol] : null;\n  var threw = true;\n  if (timerAsyncId !== null)\n    timerEmitBefore(timerAsyncId, timer[trigger_id_symbol]);\n  try {\n    ontimeout(timer);\n    threw = false;\n  } finally {\n    if (timerAsyncId !== null) {\n      if (!threw)\n        timerEmitAfter(timerAsyncId);\n      if (!timer._repeat && async_hook_fields[kDestroy] > 0 &&\n          !timer._destroyed) {\n        emitDestroy(timerAsyncId);\n        timer._destroyed = true;\n      }\n    }\n\n    if (!threw) return;\n\n    // Postpone all later list events to next tick. We need to do this\n    // so that the events are called in the order they were created.\n    const lists = list._unrefed === true ? unrefedLists : refedLists;\n    for (var key in lists) {\n      if (key > list.msecs) {\n        lists[key].nextTick = true;\n      }\n    }\n    // We need to continue processing after domain error handling\n    // is complete, but not by using whatever domain was left over\n    // when the timeout threw its exception.\n    const domain = process.domain;\n    process.domain = null;\n    // If we threw, we need to process the rest of the list in nextTick.\n    process.nextTick(listOnTimeoutNT, list);\n    process.domain = domain;\n  }\n}\n\n\nfunction listOnTimeoutNT(list) {\n  list._timer[kOnTimeout]();\n}\n\n\n// A convenience function for re-using TimerWrap handles more easily.\n//\n// This mostly exists to fix https://github.com/nodejs/node/issues/1264.\n// Handles in libuv take at least one `uv_run` to be registered as unreferenced.\n// Re-using an existing handle allows us to skip that, so that a second `uv_run`\n// will return no active handles, even when running `setTimeout(fn).unref()`.\nfunction reuse(item) {\n  L.remove(item);\n\n  var list = refedLists[item._idleTimeout];\n  // if empty - reuse the watcher\n  if (list && L.isEmpty(list)) {\n    debug('reuse hit');\n    list._timer.stop();\n    delete refedLists[item._idleTimeout];\n    return list._timer;\n  }\n\n  return null;\n}\n\n\n// Remove a timer. Cancels the timeout and resets the relevant timer properties.\nconst unenroll = exports.unenroll = function(item) {\n  // Fewer checks may be possible, but these cover everything.\n  if (async_hook_fields[kDestroy] > 0 &&\n      item &&\n      typeof item[async_id_symbol] === 'number' &&\n      !item._destroyed) {\n    emitDestroy(item[async_id_symbol]);\n    item._destroyed = true;\n  }\n\n  var handle = reuse(item);\n  if (handle) {\n    debug('unenroll: list empty');\n    handle.close();\n  }\n  // if active is called later, then we want to make sure not to insert again\n  item._idleTimeout = -1;\n};\n\n\n// Make a regular object able to act as a timer by setting some properties.\n// This function does not start the timer, see `active()`.\n// Using existing objects as timers slightly reduces object overhead.\nexports.enroll = function(item, msecs) {\n  if (typeof msecs !== 'number') {\n    throw new TypeError('\"msecs\" argument must be a number');\n  }\n\n  if (msecs < 0 || !isFinite(msecs)) {\n    throw new RangeError('\"msecs\" argument must be ' +\n                         'a non-negative finite number');\n  }\n\n  // if this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > TIMEOUT_MAX) {\n    msecs = TIMEOUT_MAX;\n  }\n\n  item._idleTimeout = msecs;\n  L.init(item);\n};\n\n\n/*\n * DOM-style timers\n */\n\n\nfunction setTimeout(callback, after, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var len = arguments.length;\n  var args;\n  if (len === 3) {\n    args = [arg1];\n  } else if (len === 4) {\n    args = [arg1, arg2];\n  } else if (len > 4) {\n    args = [arg1, arg2, arg3];\n    for (var i = 5; i < len; i++)\n      // extend array dynamically, makes .apply run much faster in v6.0.0\n      args[i - 2] = arguments[i];\n  }\n\n  return createSingleTimeout(callback, after, args);\n}\n\nsetTimeout[internalUtil.promisify.custom] = function(after, value) {\n  const promise = createPromise();\n  createSingleTimeout(promise, after, [value]);\n  return promise;\n};\n\nexports.setTimeout = setTimeout;\n\nfunction createSingleTimeout(callback, after, args) {\n  after *= 1; // coalesce to number or NaN\n  if (!(after >= 1 && after <= TIMEOUT_MAX))\n    after = 1; // schedule on next tick, follows browser behaviour\n\n  var timer = new Timeout(after, callback, args);\n  if (process.domain)\n    timer.domain = process.domain;\n\n  active(timer);\n\n  return timer;\n}\n\n\nfunction ontimeout(timer) {\n  var args = timer._timerArgs;\n  var callback = timer._onTimeout;\n  if (typeof callback !== 'function')\n    return promiseResolve(callback, args[0]);\n  if (!args)\n    timer._onTimeout();\n  else {\n    switch (args.length) {\n      case 1:\n        timer._onTimeout(args[0]);\n        break;\n      case 2:\n        timer._onTimeout(args[0], args[1]);\n        break;\n      case 3:\n        timer._onTimeout(args[0], args[1], args[2]);\n        break;\n      default:\n        Function.prototype.apply.call(callback, timer, args);\n    }\n  }\n  if (timer._repeat)\n    rearm(timer);\n}\n\n\nfunction rearm(timer) {\n  // // Do not re-arm unenroll'd or closed timers.\n  if (timer._idleTimeout === -1) return;\n\n  // If timer is unref'd (or was - it's permanently removed from the list.)\n  if (timer._handle && timer instanceof Timeout) {\n    timer._handle.start(timer._repeat);\n  } else {\n    timer._idleTimeout = timer._repeat;\n    active(timer);\n  }\n}\n\n\nconst clearTimeout = exports.clearTimeout = function(timer) {\n  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {\n    timer[kOnTimeout] = timer._onTimeout = null;\n    if (timer instanceof Timeout) {\n      timer.close(); // for after === 0\n    } else {\n      unenroll(timer);\n    }\n  }\n};\n\n\nexports.setInterval = function(callback, repeat, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var len = arguments.length;\n  var args;\n  if (len === 3) {\n    args = [arg1];\n  } else if (len === 4) {\n    args = [arg1, arg2];\n  } else if (len > 4) {\n    args = [arg1, arg2, arg3];\n    for (var i = 5; i < len; i++)\n      // extend array dynamically, makes .apply run much faster in v6.0.0\n      args[i - 2] = arguments[i];\n  }\n\n  return createRepeatTimeout(callback, repeat, args);\n};\n\nfunction createRepeatTimeout(callback, repeat, args) {\n  repeat *= 1; // coalesce to number or NaN\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX))\n    repeat = 1; // schedule on next tick, follows browser behaviour\n\n  var timer = new Timeout(repeat, callback, args);\n  timer._repeat = repeat;\n  if (process.domain)\n    timer.domain = process.domain;\n\n  active(timer);\n\n  return timer;\n}\n\nexports.clearInterval = function(timer) {\n  if (timer && timer._repeat) {\n    timer._repeat = null;\n    clearTimeout(timer);\n  }\n};\n\n\nfunction Timeout(after, callback, args) {\n  this._called = false;\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  this._onTimeout = callback;\n  this._timerArgs = args;\n  this._repeat = null;\n  this._destroyed = false;\n  this[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n  this[trigger_id_symbol] = initTriggerId();\n  if (async_hook_fields[kInit] > 0)\n    emitInit(this[async_id_symbol], 'Timeout', this[trigger_id_symbol], this);\n}\n\n\nfunction unrefdHandle() {\n  // Don't attempt to call the callback if it is not a function.\n  if (typeof this.owner._onTimeout === 'function') {\n    ontimeout(this.owner);\n  }\n\n  // Make sure we clean up if the callback is no longer a function\n  // even if the timer is an interval.\n  if (!this.owner._repeat ||\n      typeof this.owner._onTimeout !== 'function') {\n    this.owner.close();\n  }\n}\n\n\nTimeout.prototype.unref = function() {\n  if (this._handle) {\n    this._handle.unref();\n  } else if (typeof this._onTimeout === 'function') {\n    var now = TimerWrap.now();\n    if (!this._idleStart) this._idleStart = now;\n    var delay = this._idleStart + this._idleTimeout - now;\n    if (delay < 0) delay = 0;\n\n    // Prevent running cb again when unref() is called during the same cb\n    if (this._called && !this._repeat) {\n      unenroll(this);\n      return;\n    }\n\n    var handle = reuse(this);\n\n    this._handle = handle || new TimerWrap();\n    this._handle.owner = this;\n    this._handle[kOnTimeout] = unrefdHandle;\n    this._handle.start(delay);\n    this._handle.domain = this.domain;\n    this._handle.unref();\n  }\n  return this;\n};\n\nTimeout.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n  return this;\n};\n\nTimeout.prototype.close = function() {\n  this._onTimeout = null;\n  if (this._handle) {\n    // Fewer checks may be possible, but these cover everything.\n    if (async_hook_fields[kDestroy] > 0 &&\n        this &&\n        typeof this[async_id_symbol] === 'number' &&\n        !this._destroyed) {\n      emitDestroy(this[async_id_symbol]);\n      this._destroyed = true;\n    }\n\n    this._idleTimeout = -1;\n    this._handle[kOnTimeout] = null;\n    this._handle.close();\n  } else {\n    unenroll(this);\n  }\n  return this;\n};\n\n\n// A linked list for storing `setImmediate()` requests\nfunction ImmediateList() {\n  this.head = null;\n  this.tail = null;\n}\n\n// Appends an item to the end of the linked list, adjusting the current tail's\n// previous and next pointers where applicable\nImmediateList.prototype.append = function(item) {\n  if (this.tail) {\n    this.tail._idleNext = item;\n    item._idlePrev = this.tail;\n  } else {\n    this.head = item;\n  }\n  this.tail = item;\n};\n\n// Removes an item from the linked list, adjusting the pointers of adjacent\n// items and the linked list's head or tail pointers as necessary\nImmediateList.prototype.remove = function(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  if (item === this.head)\n    this.head = item._idleNext;\n  if (item === this.tail)\n    this.tail = item._idlePrev;\n\n  item._idleNext = null;\n  item._idlePrev = null;\n};\n\n// Create a single linked list instance only once at startup\nvar immediateQueue = new ImmediateList();\n\n\nfunction processImmediate() {\n  var immediate = immediateQueue.head;\n  var tail = immediateQueue.tail;\n  var domain;\n\n  // Clear the linked list early in case new `setImmediate()` calls occur while\n  // immediate callbacks are executed\n  immediateQueue.head = immediateQueue.tail = null;\n\n  while (immediate) {\n    domain = immediate.domain;\n\n    if (!immediate._onImmediate) {\n      immediate = immediate._idleNext;\n      continue;\n    }\n\n    if (domain)\n      domain.enter();\n\n    immediate._callback = immediate._onImmediate;\n\n    // Save next in case `clearImmediate(immediate)` is called from callback\n    var next = immediate._idleNext;\n\n    tryOnImmediate(immediate, tail);\n\n    if (domain)\n      domain.exit();\n\n    // If `clearImmediate(immediate)` wasn't called from the callback, use the\n    // `immediate`'s next item\n    if (immediate._idleNext)\n      immediate = immediate._idleNext;\n    else\n      immediate = next;\n  }\n\n  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an\n  // immediate that's in |queue| is okay. Worst case is we make a superfluous\n  // call to NeedImmediateCallbackSetter().\n  if (!immediateQueue.head) {\n    process._needImmediateCallback = false;\n  }\n}\n\n\n// An optimization so that the try/finally only de-optimizes (since at least v8\n// 4.7) what is in this smaller function.\nfunction tryOnImmediate(immediate, oldTail) {\n  var threw = true;\n  timerEmitBefore(immediate[async_id_symbol], immediate[trigger_id_symbol]);\n  try {\n    // make the actual call outside the try/catch to allow it to be optimized\n    runCallback(immediate);\n    threw = false;\n  } finally {\n    // clearImmediate checks _callback === null for kDestroy hooks.\n    immediate._callback = null;\n    if (!threw)\n      timerEmitAfter(immediate[async_id_symbol]);\n    if (async_hook_fields[kDestroy] > 0 && !immediate._destroyed) {\n      emitDestroy(immediate[async_id_symbol]);\n      immediate._destroyed = true;\n    }\n\n    if (threw && immediate._idleNext) {\n      // Handle any remaining on next tick, assuming we're still alive to do so.\n      const curHead = immediateQueue.head;\n      const next = immediate._idleNext;\n      if (curHead) {\n        curHead._idlePrev = oldTail;\n        oldTail._idleNext = curHead;\n        next._idlePrev = null;\n        immediateQueue.head = next;\n      } else {\n        immediateQueue.head = next;\n        immediateQueue.tail = oldTail;\n      }\n      process.nextTick(processImmediate);\n    }\n  }\n}\n\nfunction runCallback(timer) {\n  const argv = timer._argv;\n  const argc = argv ? argv.length : 0;\n  if (typeof timer._callback !== 'function')\n    return promiseResolve(timer._callback, argv[0]);\n  switch (argc) {\n    // fast-path callbacks with 0-3 arguments\n    case 0:\n      return timer._callback();\n    case 1:\n      return timer._callback(argv[0]);\n    case 2:\n      return timer._callback(argv[0], argv[1]);\n    case 3:\n      return timer._callback(argv[0], argv[1], argv[2]);\n    // more than 3 arguments run slower with .apply\n    default:\n      return Function.prototype.apply.call(timer._callback, timer, argv);\n  }\n}\n\n\nfunction Immediate() {\n  // assigning the callback here can cause optimize/deoptimize thrashing\n  // so have caller annotate the object (node v6.0.0, v8 5.0.71.35)\n  this._idleNext = null;\n  this._idlePrev = null;\n  this._callback = null;\n  this._argv = null;\n  this._onImmediate = null;\n  this._destroyed = false;\n  this.domain = process.domain;\n  this[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n  this[trigger_id_symbol] = initTriggerId();\n  if (async_hook_fields[kInit] > 0)\n    emitInit(this[async_id_symbol], 'Immediate', this[trigger_id_symbol], this);\n}\n\nfunction setImmediate(callback, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var i, args;\n\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 4; i < arguments.length; i++)\n        // extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 1] = arguments[i];\n      break;\n  }\n  return createImmediate(args, callback);\n}\n\nsetImmediate[internalUtil.promisify.custom] = function(value) {\n  const promise = createPromise();\n  createImmediate([value], promise);\n  return promise;\n};\n\nexports.setImmediate = setImmediate;\n\nfunction createImmediate(args, callback) {\n  // declaring it `const immediate` causes v6.0.0 to deoptimize this function\n  var immediate = new Immediate();\n  immediate._callback = callback;\n  immediate._argv = args;\n  immediate._onImmediate = callback;\n\n  if (!process._needImmediateCallback) {\n    process._needImmediateCallback = true;\n    process._immediateCallback = processImmediate;\n  }\n\n  immediateQueue.append(immediate);\n\n  return immediate;\n}\n\n\nexports.clearImmediate = function(immediate) {\n  if (!immediate) return;\n\n  if (async_hook_fields[kDestroy] > 0 &&\n      immediate._callback !== null &&\n      !immediate._destroyed) {\n    emitDestroy(immediate[async_id_symbol]);\n    immediate._destroyed = true;\n  }\n\n  immediate._onImmediate = null;\n\n  immediateQueue.remove(immediate);\n\n  if (!immediateQueue.head) {\n    process._needImmediateCallback = false;\n  }\n};\n\n});",
      "pkgUrl": "(system)"
    },
    {
      "id": "56",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
      "source": "(function (exports, require, module, __filename, __dirname) { 'use strict'\n\nconst shelljs = require('shelljs')\nconst arcParse = require('@architect/parser')\n\nsetInterval(run, 1000)\n\nfunction run () {\n  a()\n}\n\nfunction a () {\n  console.log(new Date(), 'a()')\n  wait(300)\n  b()\n  wait(300)\n}\n\nfunction b () {\n  console.log(new Date(), 'b()')\n  wait(300)\n}\n\nfunction wait (ms) {\n  const end = Date.now() + ms\n  while (Date.now() < end) {\n    shelljs.ls('*')\n    arcParse('# this is a comment\\n@section\\nvalue')\n  }\n}\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer"
    },
    {
      "id": "58",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/common.js",
      "source": "(function (exports, require, module, __filename, __dirname) { // Ignore warning about 'new String()'\n/* eslint no-new-wrappers: 0 */\n'use strict';\n\nvar os = require('os');\nvar fs = require('fs');\nvar glob = require('glob');\nvar shell = require('..');\n\nvar shellMethods = Object.create(shell);\n\n// objectAssign(target_obj, source_obj1 [, source_obj2 ...])\n// \"Ponyfill\" for Object.assign\n//    objectAssign({A:1}, {b:2}, {c:3}) returns {A:1, b:2, c:3}\nvar objectAssign = typeof Object.assign === 'function' ?\n  Object.assign :\n  function objectAssign(target) {\n    var sources = [].slice.call(arguments, 1);\n    sources.forEach(function (source) {\n      Object.keys(source).forEach(function (key) {\n        target[key] = source[key];\n      });\n    });\n\n    return target;\n  };\nexports.extend = objectAssign;\n\n// Check if we're running under electron\nvar isElectron = Boolean(process.versions.electron);\n\n// Module globals (assume no execPath by default)\nvar DEFAULT_CONFIG = {\n  fatal: false,\n  globOptions: {},\n  maxdepth: 255,\n  noglob: false,\n  silent: false,\n  verbose: false,\n  execPath: null,\n  bufLength: 64 * 1024, // 64KB\n};\n\nvar config = {\n  reset: function () {\n    objectAssign(this, DEFAULT_CONFIG);\n    if (!isElectron) {\n      this.execPath = process.execPath;\n    }\n  },\n  resetForTesting: function () {\n    this.reset();\n    this.silent = true;\n  },\n};\n\nconfig.reset();\nexports.config = config;\n\nvar state = {\n  error: null,\n  errorCode: 0,\n  currentCmd: 'shell.js',\n  tempDir: null,\n};\nexports.state = state;\n\ndelete process.env.OLDPWD; // initially, there's no previous directory\n\n// This is populated by calls to commonl.wrap()\nvar pipeMethods = [];\n\n// Reliably test if something is any sort of javascript object\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\nexports.isObject = isObject;\n\nfunction log() {\n  /* istanbul ignore next */\n  if (!config.silent) {\n    console.error.apply(console, arguments);\n  }\n}\nexports.log = log;\n\n// Converts strings to be equivalent across all platforms. Primarily responsible\n// for making sure we use '/' instead of '\\' as path separators, but this may be\n// expanded in the future if necessary\nfunction convertErrorOutput(msg) {\n  if (typeof msg !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n  return msg.replace(/\\\\/g, '/');\n}\nexports.convertErrorOutput = convertErrorOutput;\n\n// Shows error message. Throws if config.fatal is true\nfunction error(msg, _code, options) {\n  // Validate input\n  if (typeof msg !== 'string') throw new Error('msg must be a string');\n\n  var DEFAULT_OPTIONS = {\n    continue: false,\n    code: 1,\n    prefix: state.currentCmd + ': ',\n    silent: false,\n  };\n\n  if (typeof _code === 'number' && isObject(options)) {\n    options.code = _code;\n  } else if (isObject(_code)) { // no 'code'\n    options = _code;\n  } else if (typeof _code === 'number') { // no 'options'\n    options = { code: _code };\n  } else if (typeof _code !== 'number') { // only 'msg'\n    options = {};\n  }\n  options = objectAssign({}, DEFAULT_OPTIONS, options);\n\n  if (!state.errorCode) state.errorCode = options.code;\n\n  var logEntry = convertErrorOutput(options.prefix + msg);\n  state.error = state.error ? state.error + '\\n' : '';\n  state.error += logEntry;\n\n  // Throw an error, or log the entry\n  if (config.fatal) throw new Error(logEntry);\n  if (msg.length > 0 && !options.silent) log(logEntry);\n\n  if (!options.continue) {\n    throw {\n      msg: 'earlyExit',\n      retValue: (new ShellString('', state.error, state.errorCode)),\n    };\n  }\n}\nexports.error = error;\n\n//@\n//@ ### ShellString(str)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var foo = ShellString('hello world');\n//@ ```\n//@\n//@ Turns a regular string into a string-like object similar to what each\n//@ command returns. This has special methods, like `.to()` and `.toEnd()`\nfunction ShellString(stdout, stderr, code) {\n  var that;\n  if (stdout instanceof Array) {\n    that = stdout;\n    that.stdout = stdout.join('\\n');\n    if (stdout.length > 0) that.stdout += '\\n';\n  } else {\n    that = new String(stdout);\n    that.stdout = stdout;\n  }\n  that.stderr = stderr;\n  that.code = code;\n  // A list of all commands that can appear on the right-hand side of a pipe\n  // (populated by calls to common.wrap())\n  pipeMethods.forEach(function (cmd) {\n    that[cmd] = shellMethods[cmd].bind(that);\n  });\n  return that;\n}\n\nexports.ShellString = ShellString;\n\n// Return the home directory in a platform-agnostic way, with consideration for\n// older versions of node\nfunction getUserHome() {\n  var result;\n  if (os.homedir) {\n    result = os.homedir(); // node 3+\n  } else {\n    result = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];\n  }\n  return result;\n}\nexports.getUserHome = getUserHome;\n\n// Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\n// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:\n//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});\nfunction parseOptions(opt, map, errorOptions) {\n  // Validate input\n  if (typeof opt !== 'string' && !isObject(opt)) {\n    throw new Error('options must be strings or key-value pairs');\n  } else if (!isObject(map)) {\n    throw new Error('parseOptions() internal error: map must be an object');\n  } else if (errorOptions && !isObject(errorOptions)) {\n    throw new Error('parseOptions() internal error: errorOptions must be object');\n  }\n\n  // All options are false by default\n  var options = {};\n  Object.keys(map).forEach(function (letter) {\n    var optName = map[letter];\n    if (optName[0] !== '!') {\n      options[optName] = false;\n    }\n  });\n\n  if (opt === '') return options; // defaults\n\n  if (typeof opt === 'string') {\n    if (opt[0] !== '-') {\n      error(\"Options string must start with a '-'\", errorOptions || {});\n    }\n\n    // e.g. chars = ['R', 'f']\n    var chars = opt.slice(1).split('');\n\n    chars.forEach(function (c) {\n      if (c in map) {\n        var optionName = map[c];\n        if (optionName[0] === '!') {\n          options[optionName.slice(1)] = false;\n        } else {\n          options[optionName] = true;\n        }\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  } else { // opt is an Object\n    Object.keys(opt).forEach(function (key) {\n      // key is a string of the form '-r', '-d', etc.\n      var c = key[1];\n      if (c in map) {\n        var optionName = map[c];\n        options[optionName] = opt[key]; // assign the given value\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  }\n  return options;\n}\nexports.parseOptions = parseOptions;\n\n// Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\nfunction expand(list) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('must be an array');\n  }\n  var expanded = [];\n  list.forEach(function (listEl) {\n    // Don't expand non-strings\n    if (typeof listEl !== 'string') {\n      expanded.push(listEl);\n    } else {\n      var ret;\n      try {\n        ret = glob.sync(listEl, config.globOptions);\n        // if nothing matched, interpret the string literally\n        ret = ret.length > 0 ? ret : [listEl];\n      } catch (e) {\n        // if glob fails, interpret the string literally\n        ret = [listEl];\n      }\n      expanded = expanded.concat(ret);\n    }\n  });\n  return expanded;\n}\nexports.expand = expand;\n\n// Normalizes Buffer creation, using Buffer.alloc if possible.\n// Also provides a good default buffer length for most use cases.\nvar buffer = typeof Buffer.alloc === 'function' ?\n  function (len) {\n    return Buffer.alloc(len || config.bufLength);\n  } :\n  function (len) {\n    return new Buffer(len || config.bufLength);\n  };\nexports.buffer = buffer;\n\n// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (e) {\n    // Try to override file permission\n    /* istanbul ignore next */\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\nexports.unlinkSync = unlinkSync;\n\n// e.g. 'shelljs_a5f185d0443ca...'\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1) {\n      return parseInt(16 * Math.random(), 10).toString(16);\n    }\n    var hash = '';\n    for (var i = 0; i < count; i++) {\n      hash += randomHash(1);\n    }\n    return hash;\n  }\n\n  return 'shelljs_' + randomHash(20);\n}\nexports.randomFileName = randomFileName;\n\n// Common wrapper for all Unix-like commands that performs glob expansion,\n// command-logging, and other nice things\nfunction wrap(cmd, fn, options) {\n  options = options || {};\n  if (options.canReceivePipe) {\n    pipeMethods.push(cmd);\n  }\n  return function () {\n    var retValue = null;\n\n    state.currentCmd = cmd;\n    state.error = null;\n    state.errorCode = 0;\n\n    try {\n      var args = [].slice.call(arguments, 0);\n\n      // Log the command to stderr, if appropriate\n      if (config.verbose) {\n        console.error.apply(console, [cmd].concat(args));\n      }\n\n      // If this is coming from a pipe, let's set the pipedValue (otherwise, set\n      // it to the empty string)\n      state.pipedValue = (this && typeof this.stdout === 'string') ? this.stdout : '';\n\n      if (options.unix === false) { // this branch is for exec()\n        retValue = fn.apply(this, args);\n      } else { // and this branch is for everything else\n        if (isObject(args[0]) && args[0].constructor.name === 'Object') {\n          // a no-op, allowing the syntax `touch({'-r': file}, ...)`\n        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {\n          args.unshift(''); // only add dummy option if '-option' not already present\n        }\n\n        // flatten out arrays that are arguments, to make the syntax:\n        //    `cp([file1, file2, file3], dest);`\n        // equivalent to:\n        //    `cp(file1, file2, file3, dest);`\n        args = args.reduce(function (accum, cur) {\n          if (Array.isArray(cur)) {\n            return accum.concat(cur);\n          }\n          accum.push(cur);\n          return accum;\n        }, []);\n\n        // Convert ShellStrings (basically just String objects) to regular strings\n        args = args.map(function (arg) {\n          if (isObject(arg) && arg.constructor.name === 'String') {\n            return arg.toString();\n          }\n          return arg;\n        });\n\n        // Expand the '~' if appropriate\n        var homeDir = getUserHome();\n        args = args.map(function (arg) {\n          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {\n            return arg.replace(/^~/, homeDir);\n          }\n          return arg;\n        });\n\n        // Perform glob-expansion on all arguments after globStart, but preserve\n        // the arguments before it (like regexes for sed and grep)\n        if (!config.noglob && options.allowGlobbing === true) {\n          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));\n        }\n\n        try {\n          // parse options if options are provided\n          if (isObject(options.cmdOptions)) {\n            args[0] = parseOptions(args[0], options.cmdOptions);\n          }\n\n          retValue = fn.apply(this, args);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (e.msg === 'earlyExit') {\n            retValue = e.retValue;\n          } else {\n            throw e; // this is probably a bug that should be thrown up the call stack\n          }\n        }\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        console.error('ShellJS: internal error');\n        console.error(e.stack || e);\n        process.exit(1);\n      }\n      if (config.fatal) throw e;\n    }\n\n    if (options.wrapOutput &&\n        (typeof retValue === 'string' || Array.isArray(retValue))) {\n      retValue = new ShellString(retValue, state.error, state.errorCode);\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\nexports.wrap = wrap;\n\n// This returns all the input that is piped into the current command (or the\n// empty string, if this isn't on the right-hand side of a pipe\nfunction _readFromPipe() {\n  return state.pipedValue;\n}\nexports.readFromPipe = _readFromPipe;\n\nvar DEFAULT_WRAP_OPTIONS = {\n  allowGlobbing: true,\n  canReceivePipe: false,\n  cmdOptions: false,\n  globStart: 1,\n  pipeOnly: false,\n  unix: true,\n  wrapOutput: true,\n  overWrite: false,\n};\n\n// Register a new ShellJS command\nfunction _register(name, implementation, wrapOptions) {\n  wrapOptions = wrapOptions || {};\n  // If an option isn't specified, use the default\n  wrapOptions = objectAssign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);\n\n  if (shell[name] && !wrapOptions.overWrite) {\n    throw new Error('unable to overwrite `' + name + '` command');\n  }\n\n  if (wrapOptions.pipeOnly) {\n    wrapOptions.canReceivePipe = true;\n    shellMethods[name] = wrap(name, implementation, wrapOptions);\n  } else {\n    shell[name] = wrap(name, implementation, wrapOptions);\n  }\n}\nexports.register = _register;\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs"
    },
    {
      "id": "92",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs/src/ls.js",
      "source": "(function (exports, require, module, __filename, __dirname) { var path = require('path');\nvar fs = require('fs');\nvar common = require('./common');\nvar glob = require('glob');\n\nvar globPatternRecursive = path.sep + '**';\n\ncommon.register('ls', _ls, {\n  cmdOptions: {\n    'R': 'recursive',\n    'A': 'all',\n    'L': 'link',\n    'a': 'all_deprecated',\n    'd': 'directory',\n    'l': 'long',\n  },\n});\n\n//@\n//@ ### ls([options,] [path, ...])\n//@ ### ls([options,] path_array)\n//@ Available options:\n//@\n//@ + `-R`: recursive\n//@ + `-A`: all files (include files beginning with `.`, except for `.` and `..`)\n//@ + `-L`: follow symlinks\n//@ + `-d`: list directories themselves, not their contents\n//@ + `-l`: list objects representing each file, each with fields containing `ls\n//@         -l` output fields. See\n//@         [fs.Stats](https://nodejs.org/api/fs.html#fs_class_fs_stats)\n//@         for more info\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ls('projs/*.js');\n//@ ls('-R', '/users/me', '/tmp');\n//@ ls('-R', ['/users/me', '/tmp']); // same as above\n//@ ls('-l', 'file.txt'); // { name: 'file.txt', mode: 33188, nlink: 1, ...}\n//@ ```\n//@\n//@ Returns array of files in the given path, or in current directory if no path provided.\nfunction _ls(options, paths) {\n  if (options.all_deprecated) {\n    // We won't support the -a option as it's hard to image why it's useful\n    // (it includes '.' and '..' in addition to '.*' files)\n    // For backwards compatibility we'll dump a deprecated message and proceed as before\n    common.log('ls: Option -a is deprecated. Use -A instead');\n    options.all = true;\n  }\n\n  if (!paths) {\n    paths = ['.'];\n  } else {\n    paths = [].slice.call(arguments, 1);\n  }\n\n  var list = [];\n\n  function pushFile(abs, relName, stat) {\n    if (process.platform === 'win32') {\n      relName = relName.replace(/\\\\/g, '/');\n    }\n    if (options.long) {\n      stat = stat || (options.link ? fs.statSync(abs) : fs.lstatSync(abs));\n      list.push(addLsAttributes(relName, stat));\n    } else {\n      // list.push(path.relative(rel || '.', file));\n      list.push(relName);\n    }\n  }\n\n  paths.forEach(function (p) {\n    var stat;\n\n    try {\n      stat = options.link ? fs.statSync(p) : fs.lstatSync(p);\n    } catch (e) {\n      common.error('no such file or directory: ' + p, 2, { continue: true });\n      return;\n    }\n\n    // If the stat succeeded\n    if (stat.isDirectory() && !options.directory) {\n      if (options.recursive) {\n        // use glob, because it's simple\n        glob.sync(p + globPatternRecursive, { dot: options.all, follow: options.link })\n          .forEach(function (item) {\n            // Glob pattern returns the directory itself and needs to be filtered out.\n            if (path.relative(p, item)) {\n              pushFile(item, path.relative(p, item));\n            }\n          });\n      } else if (options.all) {\n        // use fs.readdirSync, because it's fast\n        fs.readdirSync(p).forEach(function (item) {\n          pushFile(path.join(p, item), item);\n        });\n      } else {\n        // use fs.readdirSync and then filter out secret files\n        fs.readdirSync(p).forEach(function (item) {\n          if (item[0] !== '.') {\n            pushFile(path.join(p, item), item);\n          }\n        });\n      }\n    } else {\n      pushFile(p, p, stat);\n    }\n  });\n\n  // Add methods, to make this more compatible with ShellStrings\n  return list;\n}\n\nfunction addLsAttributes(pathName, stats) {\n  // Note: this object will contain more information than .toString() returns\n  stats.name = pathName;\n  stats.toString = function () {\n    // Return a string resembling unix's `ls -l` format\n    return [this.mode, this.nlink, this.uid, this.gid, this.size, this.mtime, this.name].join(' ');\n  };\n  return stats;\n}\n\nmodule.exports = _ls;\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs"
    },
    {
      "id": "6",
      "url": "native array.js",
      "pkgUrl": "(system)"
    },
    {
      "id": "45",
      "url": "fs.js",
      "source": "(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers, keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\nconst constants = process.binding('constants').fs;\nconst { S_IFIFO, S_IFLNK, S_IFMT, S_IFREG, S_IFSOCK } = constants;\nconst util = require('util');\nconst pathModule = require('path');\nconst { isUint8Array, createPromise, promiseResolve } = process.binding('util');\n\nconst binding = process.binding('fs');\nconst fs = exports;\nconst Buffer = require('buffer').Buffer;\nconst Stream = require('stream').Stream;\nconst EventEmitter = require('events');\nconst FSReqWrap = binding.FSReqWrap;\nconst FSEvent = process.binding('fs_event_wrap').FSEvent;\nconst internalFS = require('internal/fs');\nconst internalURL = require('internal/url');\nconst internalUtil = require('internal/util');\nconst assertEncoding = internalFS.assertEncoding;\nconst stringToFlags = internalFS.stringToFlags;\nconst getPathFromURL = internalURL.getPathFromURL;\n\nObject.defineProperty(exports, 'constants', {\n  configurable: false,\n  enumerable: true,\n  value: constants\n});\n\nconst Readable = Stream.Readable;\nconst Writable = Stream.Writable;\n\nconst kMinPoolSpace = 128;\nconst kMaxLength = require('buffer').kMaxLength;\n\nconst isWindows = process.platform === 'win32';\n\nconst DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\nconst errnoException = util._errnoException;\n\nfunction getOptions(options, defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = util._extend({}, defaultOptions);\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new TypeError('\"options\" must be a string or an object, got ' +\n                        typeof options + ' instead.');\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n  return options;\n}\n\nfunction copyObject(source) {\n  var target = {};\n  for (var key in source)\n    target[key] = source[key];\n  return target;\n}\n\nfunction rethrow() {\n  // TODO(thefourtheye) Throw error instead of warning in major version > 7\n  process.emitWarning(\n    'Calling an asynchronous function without callback is deprecated.',\n    'DeprecationWarning', 'DEP0013', rethrow\n  );\n\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  if (DEBUG) {\n    var backtrace = new Error();\n    return function(err) {\n      if (err) {\n        backtrace.stack = err.name + ': ' + err.message +\n                          backtrace.stack.substr(backtrace.name.length);\n        throw backtrace;\n      }\n    };\n  }\n\n  return function(err) {\n    if (err) {\n      throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n    }\n  };\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  if (cb === undefined) {\n    return rethrow();\n  }\n\n  if (typeof cb !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  return function() {\n    return cb.apply(null, arguments);\n  };\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization, since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  if (cb === undefined) {\n    return rethrow();\n  }\n\n  if (typeof cb !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  return function(err) {\n    if (err) return cb(err);\n    cb(err, statsFromValues());\n  };\n}\n\nfunction nullCheck(path, callback) {\n  if (('' + path).indexOf('\\u0000') !== -1) {\n    var er = new Error('Path must be a string without null bytes');\n    er.code = 'ENOENT';\n    if (typeof callback !== 'function')\n      throw er;\n    process.nextTick(callback, er);\n    return false;\n  }\n  return true;\n}\n\nfunction isFd(path) {\n  return (path >>> 0) === path;\n}\n\n// Constructor for file stats.\nfunction Stats(\n    dev,\n    mode,\n    nlink,\n    uid,\n    gid,\n    rdev,\n    blksize,\n    ino,\n    size,\n    blocks,\n    atim_msec,\n    mtim_msec,\n    ctim_msec,\n    birthtim_msec) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n  this.atimeMs = atim_msec;\n  this.mtimeMs = mtim_msec;\n  this.ctimeMs = ctim_msec;\n  this.birthtimeMs = birthtim_msec;\n  this.atime = new Date(atim_msec + 0.5);\n  this.mtime = new Date(mtim_msec + 0.5);\n  this.ctime = new Date(ctim_msec + 0.5);\n  this.birthtime = new Date(birthtim_msec + 0.5);\n}\nfs.Stats = Stats;\n\nStats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & S_IFMT) === property);\n};\n\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst statValues = binding.getStatValues();\n\nfunction statsFromValues() {\n  return new Stats(statValues[0], statValues[1], statValues[2], statValues[3],\n                   statValues[4], statValues[5],\n                   statValues[6] < 0 ? undefined : statValues[6], statValues[7],\n                   statValues[8], statValues[9] < 0 ? undefined : statValues[9],\n                   statValues[10], statValues[11], statValues[12],\n                   statValues[13]);\n}\n\n// Don't allow mode to accidentally be overwritten.\nObject.defineProperties(fs, {\n  F_OK: {enumerable: true, value: constants.F_OK || 0},\n  R_OK: {enumerable: true, value: constants.R_OK || 0},\n  W_OK: {enumerable: true, value: constants.W_OK || 0},\n  X_OK: {enumerable: true, value: constants.X_OK || 0},\n});\n\nfunction handleError(val, callback) {\n  if (val instanceof Error) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback, val);\n      return true;\n    } else throw val;\n  }\n  return false;\n}\n\nfs.access = function(path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = fs.F_OK;\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n\n  if (!nullCheck(path, callback))\n    return;\n\n  mode = mode | 0;\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.access(pathModule._makeLong(path), mode, req);\n};\n\nfs.accessSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n\n  if (mode === undefined)\n    mode = fs.F_OK;\n  else\n    mode = mode | 0;\n\n  binding.access(pathModule._makeLong(path), mode);\n};\n\nfs.exists = function(path, callback) {\n  if (handleError((path = getPathFromURL(path)), cb))\n    return;\n  if (!nullCheck(path, cb)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = cb;\n  binding.stat(pathModule._makeLong(path), req);\n  function cb(err) {\n    if (callback) callback(err ? false : true);\n  }\n};\n\nObject.defineProperty(fs.exists, internalUtil.promisify.custom, {\n  value: (path) => {\n    const promise = createPromise();\n    fs.exists(path, (exists) => promiseResolve(promise, exists));\n    return promise;\n  }\n});\n\n\nfs.existsSync = function(path) {\n  try {\n    handleError((path = getPathFromURL(path)));\n    nullCheck(path);\n    binding.stat(pathModule._makeLong(path));\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nfs.readFile = function(path, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { flag: 'r' });\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback))\n    return;\n\n  var context = new ReadFileContext(callback, options.encoding);\n  context.isUserFd = isFd(path); // file descriptor ownership\n  var req = new FSReqWrap();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n\n  if (context.isUserFd) {\n    process.nextTick(function() {\n      req.oncomplete(null, path);\n    });\n    return;\n  }\n\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(options.flag || 'r'),\n               0o666,\n               req);\n};\n\nconst kReadFileBufferLength = 8 * 1024;\n\nfunction ReadFileContext(callback, encoding) {\n  this.fd = undefined;\n  this.isUserFd = undefined;\n  this.size = undefined;\n  this.callback = callback;\n  this.buffers = null;\n  this.buffer = null;\n  this.pos = 0;\n  this.encoding = encoding;\n  this.err = null;\n}\n\nReadFileContext.prototype.read = function() {\n  var buffer;\n  var offset;\n  var length;\n\n  if (this.size === 0) {\n    buffer = this.buffer = Buffer.allocUnsafeSlow(kReadFileBufferLength);\n    offset = 0;\n    length = kReadFileBufferLength;\n  } else {\n    buffer = this.buffer;\n    offset = this.pos;\n    length = this.size - this.pos;\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterRead;\n  req.context = this;\n\n  binding.read(this.fd, buffer, offset, length, -1, req);\n};\n\nReadFileContext.prototype.close = function(err) {\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterClose;\n  req.context = this;\n  this.err = err;\n\n  if (this.isUserFd) {\n    process.nextTick(function() {\n      req.oncomplete(null);\n    });\n    return;\n  }\n\n  binding.close(this.fd, req);\n};\n\nfunction readFileAfterOpen(err, fd) {\n  var context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd, req);\n}\n\nfunction readFileAfterStat(err) {\n  var context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  var size;\n  if ((statValues[1/*mode*/] & S_IFMT) === S_IFREG)\n    size = context.size = statValues[8/*size*/];\n  else\n    size = context.size = 0;\n\n  if (size === 0) {\n    context.buffers = [];\n    context.read();\n    return;\n  }\n\n  if (size > kMaxLength) {\n    err = new RangeError('File size is greater than possible Buffer: ' +\n                         `0x${kMaxLength.toString(16)} bytes`);\n    return context.close(err);\n  }\n\n  context.buffer = Buffer.allocUnsafeSlow(size);\n  context.read();\n}\n\nfunction readFileAfterRead(err, bytesRead) {\n  var context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  if (bytesRead === 0)\n    return context.close();\n\n  context.pos += bytesRead;\n\n  if (context.size !== 0) {\n    if (context.pos === context.size)\n      context.close();\n    else\n      context.read();\n  } else {\n    // unknown size, just read until we don't get bytes.\n    context.buffers.push(context.buffer.slice(0, bytesRead));\n    context.read();\n  }\n}\n\nfunction readFileAfterClose(err) {\n  var context = this.context;\n  var buffer = null;\n  var callback = context.callback;\n\n  if (context.err || err)\n    return callback(context.err || err);\n\n  if (context.size === 0)\n    buffer = Buffer.concat(context.buffers, context.pos);\n  else if (context.pos < context.size)\n    buffer = context.buffer.slice(0, context.pos);\n  else\n    buffer = context.buffer;\n\n  if (context.encoding) {\n    return tryToString(buffer, context.encoding, callback);\n  }\n\n  callback(null, buffer);\n}\n\nfunction tryToString(buf, encoding, callback) {\n  try {\n    buf = buf.toString(encoding);\n  } catch (err) {\n    return callback(err);\n  }\n  callback(null, buf);\n}\n\nfunction tryStatSync(fd, isUserFd) {\n  var threw = true;\n  try {\n    binding.fstat(fd);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return !threw;\n}\n\nfunction tryCreateBuffer(size, fd, isUserFd) {\n  var threw = true;\n  var buffer;\n  try {\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd, isUserFd, buffer, pos, len) {\n  var threw = true;\n  var bytesRead;\n  try {\n    bytesRead = fs.readSync(fd, buffer, pos, len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\nfs.readFileSync = function(path, options) {\n  options = getOptions(options, { flag: 'r' });\n  var isUserFd = isFd(path); // file descriptor ownership\n  var fd = isUserFd ? path : fs.openSync(path, options.flag || 'r', 0o666);\n\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  var size;\n  if (tryStatSync(fd, isUserFd) && (statValues[1/*mode*/] & S_IFMT) === S_IFREG)\n    size = statValues[8/*size*/];\n  else\n    size = 0;\n  var pos = 0;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size, fd, isUserFd);\n  }\n\n  var bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // the kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);\n      if (bytesRead !== 0) {\n        buffers.push(buffer.slice(0, bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // data was collected into the buffers list.\n    buffer = Buffer.concat(buffers, pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0, pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n};\n\n\n// Yes, the follow could be easily DRYed up but I provide the explicit\n// list to make the arguments clear.\n\nfs.close = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.close(fd, req);\n};\n\nfs.closeSync = function(fd) {\n  return binding.close(fd);\n};\n\nfunction modeNum(m, def) {\n  if (typeof m === 'number')\n    return m;\n  if (typeof m === 'string')\n    return parseInt(m, 8);\n  if (def)\n    return modeNum(def);\n  return undefined;\n}\n\nfs.open = function(path, flags, mode, callback_) {\n  var callback = makeCallback(arguments[arguments.length - 1]);\n  mode = modeNum(mode, 0o666);\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(flags),\n               mode,\n               req);\n};\n\nfs.openSync = function(path, flags, mode) {\n  mode = modeNum(mode, 0o666);\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\n};\n\nfs.read = function(fd, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    return process.nextTick(function() {\n      callback && callback(null, 0, buffer);\n    });\n  }\n\n  function wrapper(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback && callback(err, bytesRead || 0, buffer);\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = wrapper;\n\n  binding.read(fd, buffer, offset, length, position, req);\n};\n\nObject.defineProperty(fs.read, internalUtil.customPromisifyArgs,\n                      { value: ['bytesRead', 'buffer'], enumerable: false });\n\nfs.readSync = function(fd, buffer, offset, length, position) {\n  if (length === 0) {\n    return 0;\n  }\n\n  return binding.read(fd, buffer, offset, length, position);\n};\n\n// usage:\n//  fs.write(fd, buffer[, offset[, length[, position]]], callback);\n// OR\n//  fs.write(fd, string[, position[, encoding]], callback);\nfs.write = function(fd, buffer, offset, length, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, written || 0, buffer);\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = wrapper;\n\n  if (isUint8Array(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (typeof offset !== 'number') {\n      offset = 0;\n    }\n    if (typeof length !== 'number') {\n      length = buffer.length - offset;\n    }\n    if (typeof position !== 'number') {\n      position = null;\n    }\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\n  }\n\n  if (typeof buffer !== 'string')\n    buffer += '';\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n  callback = maybeCallback(position);\n  return binding.writeString(fd, buffer, offset, length, req);\n};\n\nObject.defineProperty(fs.write, internalUtil.customPromisifyArgs,\n                      { value: ['bytesWritten', 'buffer'], enumerable: false });\n\n// usage:\n//  fs.writeSync(fd, buffer[, offset[, length[, position]]]);\n// OR\n//  fs.writeSync(fd, string[, position[, encoding]]);\nfs.writeSync = function(fd, buffer, offset, length, position) {\n  if (isUint8Array(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (typeof offset !== 'number')\n      offset = 0;\n    if (typeof length !== 'number')\n      length = buffer.length - offset;\n    return binding.writeBuffer(fd, buffer, offset, length, position);\n  }\n  if (typeof buffer !== 'string')\n    buffer += '';\n  if (offset === undefined)\n    offset = null;\n  return binding.writeString(fd, buffer, offset, length, position);\n};\n\nfs.rename = function(oldPath, newPath, callback) {\n  callback = makeCallback(callback);\n  if (handleError((oldPath = getPathFromURL(oldPath)), callback))\n    return;\n\n  if (handleError((newPath = getPathFromURL(newPath)), callback))\n    return;\n\n  if (!nullCheck(oldPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.rename(pathModule._makeLong(oldPath),\n                 pathModule._makeLong(newPath),\n                 req);\n};\n\nfs.renameSync = function(oldPath, newPath) {\n  handleError((oldPath = getPathFromURL(oldPath)));\n  handleError((newPath = getPathFromURL(newPath)));\n  nullCheck(oldPath);\n  nullCheck(newPath);\n  return binding.rename(pathModule._makeLong(oldPath),\n                        pathModule._makeLong(newPath));\n};\n\nfs.truncate = function(path, len, callback) {\n  if (typeof path === 'number') {\n    return fs.ftruncate(path, len, callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  callback = maybeCallback(callback);\n  fs.open(path, 'r+', function(er, fd) {\n    if (er) return callback(er);\n    var req = new FSReqWrap();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd, function(er2) {\n        callback(er || er2);\n      });\n    };\n    binding.ftruncate(fd, len, req);\n  });\n};\n\nfs.truncateSync = function(path, len) {\n  if (typeof path === 'number') {\n    // legacy\n    return fs.ftruncateSync(path, len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // allow error to be thrown, but still close fd.\n  var fd = fs.openSync(path, 'r+');\n  var ret;\n\n  try {\n    ret = fs.ftruncateSync(fd, len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n};\n\nfs.ftruncate = function(fd, len, callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.ftruncate(fd, len, req);\n};\n\nfs.ftruncateSync = function(fd, len) {\n  if (len === undefined) {\n    len = 0;\n  }\n  return binding.ftruncate(fd, len);\n};\n\nfs.rmdir = function(path, callback) {\n  callback = maybeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.rmdir(pathModule._makeLong(path), req);\n};\n\nfs.rmdirSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.rmdir(pathModule._makeLong(path));\n};\n\nfs.fdatasync = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd, req);\n};\n\nfs.fdatasyncSync = function(fd) {\n  return binding.fdatasync(fd);\n};\n\nfs.fsync = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd, req);\n};\n\nfs.fsyncSync = function(fd) {\n  return binding.fsync(fd);\n};\n\nfs.mkdir = function(path, mode, callback) {\n  if (typeof mode === 'function') callback = mode;\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule._makeLong(path),\n                modeNum(mode, 0o777),\n                req);\n};\n\nfs.mkdirSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.mkdir(pathModule._makeLong(path),\n                       modeNum(mode, 0o777));\n};\n\nfs.readdir = function(path, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.readdir(pathModule._makeLong(path), options.encoding, req);\n};\n\nfs.readdirSync = function(path, options) {\n  options = getOptions(options, {});\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.readdir(pathModule._makeLong(path), options.encoding);\n};\n\nfs.fstat = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeStatsCallback(callback);\n  binding.fstat(fd, req);\n};\n\nfs.lstat = function(path, callback) {\n  callback = makeStatsCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.lstat(pathModule._makeLong(path), req);\n};\n\nfs.stat = function(path, callback) {\n  callback = makeStatsCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.stat(pathModule._makeLong(path), req);\n};\n\nfs.fstatSync = function(fd) {\n  binding.fstat(fd);\n  return statsFromValues();\n};\n\nfs.lstatSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  binding.lstat(pathModule._makeLong(path));\n  return statsFromValues();\n};\n\nfs.statSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  binding.stat(pathModule._makeLong(path));\n  return statsFromValues();\n};\n\nfs.readlink = function(path, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.readlink(pathModule._makeLong(path), options.encoding, req);\n};\n\nfs.readlinkSync = function(path, options) {\n  options = getOptions(options, {});\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.readlink(pathModule._makeLong(path), options.encoding);\n};\n\nfunction preprocessSymlinkDestination(path, type, linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  } else if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath, '..', path);\n    return pathModule._makeLong(path);\n  } else {\n    // Windows symlinks don't tolerate forward slashes.\n    return ('' + path).replace(/\\//g, '\\\\');\n  }\n}\n\nfs.symlink = function(target, path, type_, callback_) {\n  var type = (typeof type_ === 'string' ? type_ : null);\n  var callback = makeCallback(arguments[arguments.length - 1]);\n\n  if (handleError((target = getPathFromURL(target)), callback))\n    return;\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n\n  if (!nullCheck(target, callback)) return;\n  if (!nullCheck(path, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.symlink(preprocessSymlinkDestination(target, type, path),\n                  pathModule._makeLong(path),\n                  type,\n                  req);\n};\n\nfs.symlinkSync = function(target, path, type) {\n  type = (typeof type === 'string' ? type : null);\n  handleError((target = getPathFromURL(target)));\n  handleError((path = getPathFromURL(path)));\n  nullCheck(target);\n  nullCheck(path);\n\n  return binding.symlink(preprocessSymlinkDestination(target, type, path),\n                         pathModule._makeLong(path),\n                         type);\n};\n\nfs.link = function(existingPath, newPath, callback) {\n  callback = makeCallback(callback);\n\n  if (handleError((existingPath = getPathFromURL(existingPath)), callback))\n    return;\n\n  if (handleError((newPath = getPathFromURL(newPath)), callback))\n    return;\n\n  if (!nullCheck(existingPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.link(pathModule._makeLong(existingPath),\n               pathModule._makeLong(newPath),\n               req);\n};\n\nfs.linkSync = function(existingPath, newPath) {\n  handleError((existingPath = getPathFromURL(existingPath)));\n  handleError((newPath = getPathFromURL(newPath)));\n  nullCheck(existingPath);\n  nullCheck(newPath);\n  return binding.link(pathModule._makeLong(existingPath),\n                      pathModule._makeLong(newPath));\n};\n\nfs.unlink = function(path, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.unlink(pathModule._makeLong(path), req);\n};\n\nfs.unlinkSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.unlink(pathModule._makeLong(path));\n};\n\nfs.fchmod = function(fd, mode, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fchmod(fd, modeNum(mode), req);\n};\n\nfs.fchmodSync = function(fd, mode) {\n  return binding.fchmod(fd, modeNum(mode));\n};\n\nif (constants.O_SYMLINK !== undefined) {\n  fs.lchmod = function(path, mode, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function(err) {\n        fs.close(fd, function(err2) {\n          callback(err || err2);\n        });\n      });\n    });\n  };\n\n  fs.lchmodSync = function(path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var err, err2, ret;\n    try {\n      ret = fs.fchmodSync(fd, mode);\n    } catch (er) {\n      err = er;\n    }\n    try {\n      fs.closeSync(fd);\n    } catch (er) {\n      err2 = er;\n    }\n    if (err || err2) throw (err || err2);\n    return ret;\n  };\n}\n\n\nfs.chmod = function(path, mode, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.chmod(pathModule._makeLong(path),\n                modeNum(mode),\n                req);\n};\n\nfs.chmodSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\n};\n\nif (constants.O_SYMLINK !== undefined) {\n  fs.lchown = function(path, uid, gid, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      fs.fchown(fd, uid, gid, callback);\n    });\n  };\n\n  fs.lchownSync = function(path, uid, gid) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n    return fs.fchownSync(fd, uid, gid);\n  };\n}\n\nfs.fchown = function(fd, uid, gid, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fchown(fd, uid, gid, req);\n};\n\nfs.fchownSync = function(fd, uid, gid) {\n  return binding.fchown(fd, uid, gid);\n};\n\nfs.chown = function(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.chown(pathModule._makeLong(path), uid, gid, req);\n};\n\nfs.chownSync = function(path, uid, gid) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.chown(pathModule._makeLong(path), uid, gid);\n};\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time) {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (Number.isFinite(time)) {\n    if (time < 0) {\n      return Date.now() / 1000;\n    }\n    return time;\n  }\n  if (util.isDate(time)) {\n    // convert to 123.456 UNIX timestamp\n    return time.getTime() / 1000;\n  }\n  throw new Error('Cannot parse time: ' + time);\n}\n\n// exported for unit tests, not for public consumption\nfs._toUnixTimestamp = toUnixTimestamp;\n\nfs.utimes = function(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.utimes(pathModule._makeLong(path),\n                 toUnixTimestamp(atime),\n                 toUnixTimestamp(mtime),\n                 req);\n};\n\nfs.utimesSync = function(path, atime, mtime) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\n};\n\nfs.futimes = function(fd, atime, mtime, callback) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.futimes(fd, atime, mtime, req);\n};\n\nfs.futimesSync = function(fd, atime, mtime) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.futimes(fd, atime, mtime);\n};\n\nfunction writeAll(fd, isUserFd, buffer, offset, length, position, callback) {\n  // write(fd, buffer, offset, length, position, callback)\n  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd, function() {\n          callback(writeErr);\n        });\n      }\n    } else {\n      if (written === length) {\n        if (isUserFd) {\n          callback(null);\n        } else {\n          fs.close(fd, callback);\n        }\n      } else {\n        offset += written;\n        length -= written;\n        if (position !== null) {\n          position += written;\n        }\n        writeAll(fd, isUserFd, buffer, offset, length, position, callback);\n      }\n    }\n  });\n}\n\nfs.writeFile = function(path, data, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (isFd(path)) {\n    writeFd(path, true);\n    return;\n  }\n\n  fs.open(path, flag, options.mode, function(openErr, fd) {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      writeFd(fd, false);\n    }\n  });\n\n  function writeFd(fd, isUserFd) {\n    var buffer = isUint8Array(data) ?\n        data : Buffer.from('' + data, options.encoding || 'utf8');\n    var position = /a/.test(flag) ? null : 0;\n\n    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);\n  }\n};\n\nfs.writeFileSync = function(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n  const flag = options.flag || 'w';\n\n  var isUserFd = isFd(path); // file descriptor ownership\n  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\n\n  if (!isUint8Array(data)) {\n    data = Buffer.from('' + data, options.encoding || 'utf8');\n  }\n  var offset = 0;\n  var length = data.length;\n  var position = /a/.test(flag) ? null : 0;\n  try {\n    while (length > 0) {\n      var written = fs.writeSync(fd, data, offset, length, position);\n      offset += written;\n      length -= written;\n      if (position !== null) {\n        position += written;\n      }\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n};\n\nfs.appendFile = function(path, data, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path, data, options, callback);\n};\n\nfs.appendFileSync = function(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path, data, options);\n};\n\nfunction FSWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  this._handle = new FSEvent();\n  this._handle.owner = this;\n\n  this._handle.onchange = function(status, eventType, filename) {\n    if (status < 0) {\n      self._handle.close();\n      const error = !filename ?\n          errnoException(status, 'Error watching file for changes:') :\n          errnoException(status,\n                         `Error watching file ${filename} for changes:`);\n      error.filename = filename;\n      self.emit('error', error);\n    } else {\n      self.emit('change', eventType, filename);\n    }\n  };\n}\nutil.inherits(FSWatcher, EventEmitter);\n\nFSWatcher.prototype.start = function(filename,\n                                     persistent,\n                                     recursive,\n                                     encoding) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  var err = this._handle.start(pathModule._makeLong(filename),\n                               persistent,\n                               recursive,\n                               encoding);\n  if (err) {\n    this._handle.close();\n    const error = errnoException(err, `watch ${filename}`);\n    error.filename = filename;\n    throw error;\n  }\n};\n\nFSWatcher.prototype.close = function() {\n  this._handle.close();\n};\n\nfs.watch = function(filename, options, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options, {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n\n  const watcher = new FSWatcher();\n  watcher.start(filename,\n                options.persistent,\n                options.recursive,\n                options.encoding);\n\n  if (listener) {\n    watcher.addListener('change', listener);\n  }\n\n  return watcher;\n};\n\n\n// Stat Change Watchers\n\nfunction emitStop(self) {\n  self.emit('stop');\n}\n\nfunction statsFromPrevValues() {\n  return new Stats(statValues[14], statValues[15], statValues[16],\n                   statValues[17], statValues[18], statValues[19],\n                   statValues[20] < 0 ? undefined : statValues[20],\n                   statValues[21], statValues[22],\n                   statValues[23] < 0 ? undefined : statValues[23],\n                   statValues[24], statValues[25], statValues[26],\n                   statValues[27]);\n}\nfunction StatWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  this._handle = new binding.StatWatcher();\n\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n  // the sake of backwards compatibility\n  var oldStatus = -1;\n\n  this._handle.onchange = function(newStatus) {\n    if (oldStatus === -1 &&\n        newStatus === -1 &&\n        statValues[2/*new nlink*/] === statValues[16/*old nlink*/]) return;\n\n    oldStatus = newStatus;\n    self.emit('change', statsFromValues(), statsFromPrevValues());\n  };\n\n  this._handle.onstop = function() {\n    process.nextTick(emitStop, self);\n  };\n}\nutil.inherits(StatWatcher, EventEmitter);\n\n\nStatWatcher.prototype.start = function(filename, persistent, interval) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  this._handle.start(pathModule._makeLong(filename), persistent, interval);\n};\n\n\nStatWatcher.prototype.stop = function() {\n  this._handle.stop();\n};\n\n\nconst statWatchers = new Map();\n\nfs.watchFile = function(filename, options, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat;\n\n  var defaults = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007,\n    persistent: true\n  };\n\n  if (options !== null && typeof options === 'object') {\n    options = util._extend(defaults, options);\n  } else {\n    listener = options;\n    options = defaults;\n  }\n\n  if (typeof listener !== 'function') {\n    throw new Error('\"watchFile()\" requires a listener function');\n  }\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new StatWatcher();\n    stat.start(filename, options.persistent, options.interval);\n    statWatchers.set(filename, stat);\n  }\n\n  stat.addListener('change', listener);\n  return stat;\n};\n\nfs.unwatchFile = function(filename, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    stat.removeListener('change', listener);\n  } else {\n    stat.removeAllListeners('change');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n};\n\n\nvar splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\'), including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return splitRootRe.exec(str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (var i = 0; i < str.length; ++i) {\n      if (str.charCodeAt(i) !== 47/*'/'*/)\n        return str.slice(0, i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result, options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  } else {\n    return asBuffer.toString(options.encoding);\n  }\n}\n\n// Finds the next portion of a (partial) path, up to the next path delimiter\nvar nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p, i) {\n    for (; i < p.length; ++i) {\n      const ch = p.charCodeAt(i);\n      if (ch === 92/*'\\'*/ || ch === 47/*'/'*/)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p, i) { return p.indexOf('/', i); };\n}\n\nconst emptyObj = Object.create(null);\nfs.realpathSync = function realpathSync(p, options) {\n  if (!options)\n    options = emptyObj;\n  else\n    options = getOptions(options, emptyObj);\n  if (typeof p !== 'string') {\n    handleError((p = getPathFromURL(p)));\n    if (typeof p !== 'string')\n      p += '';\n  }\n  nullCheck(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[internalFS.realpathCacheKey];\n  const maybeCachedResult = cache && cache.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = Object.create(null);\n  const knownHard = Object.create(null);\n  const original = p;\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows, check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    binding.lstat(pathModule._makeLong(base));\n    knownHard[base] = true;\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    var result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      var last = p.slice(pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += p.slice(pos, result + 1);\n      base = previous + p.slice(pos, result);\n      pos = result + 1;\n    }\n\n    // continue if not a symlink, break if a pipe/socket\n    if (knownHard[base] || (cache && cache.get(base) === base)) {\n      if ((statValues[1/*mode*/] & S_IFMT) === S_IFIFO ||\n          (statValues[1/*mode*/] & S_IFMT) === S_IFSOCK) {\n        break;\n      }\n      continue;\n    }\n\n    var resolvedLink;\n    var maybeCachedResolved = cache && cache.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      var baseLong = pathModule._makeLong(base);\n      binding.lstat(baseLong);\n\n      if ((statValues[1/*mode*/] & S_IFMT) !== S_IFLNK) {\n        knownHard[base] = true;\n        if (cache) cache.set(base, base);\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      var id;\n      if (!isWindows) {\n        var dev = statValues[0/*dev*/].toString(32);\n        var ino = statValues[7/*ino*/].toString(32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        binding.stat(baseLong);\n        linkTarget = binding.readlink(baseLong);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n\n      if (cache) cache.set(base, resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      binding.lstat(pathModule._makeLong(base));\n      knownHard[base] = true;\n    }\n  }\n\n  if (cache) cache.set(original, p);\n  return encodeRealpathResult(p, options);\n};\n\n\nfs.realpath = function realpath(p, options, callback) {\n  callback = maybeCallback(typeof options === 'function' ? options : callback);\n  if (!options)\n    options = emptyObj;\n  else\n    options = getOptions(options, emptyObj);\n  if (typeof p !== 'string') {\n    if (handleError((p = getPathFromURL(p)), callback))\n      return;\n    if (typeof p !== 'string')\n      p += '';\n  }\n  if (!nullCheck(p, callback))\n    return;\n  p = pathModule.resolve(p);\n\n  const seenLinks = Object.create(null);\n  const knownHard = Object.create(null);\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows, check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base, function(err) {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null, encodeRealpathResult(p, options));\n    }\n\n    // find the next part\n    var result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      var last = p.slice(pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += p.slice(pos, result + 1);\n      base = previous + p.slice(pos, result);\n      pos = result + 1;\n    }\n\n    // continue if not a symlink, break if a pipe/socket\n    if (knownHard[base]) {\n      if ((statValues[1/*mode*/] & S_IFMT) === S_IFIFO ||\n          (statValues[1/*mode*/] & S_IFMT) === S_IFSOCK) {\n        return callback(null, encodeRealpathResult(p, options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err) {\n    if (err) return callback(err);\n\n    // Use stats array directly to avoid creating an fs.Stats instance just for\n    // our internal use.\n\n    // if not a symlink, skip to the next path part\n    if ((statValues[1/*mode*/] & S_IFMT) !== S_IFLNK) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    let id;\n    if (!isWindows) {\n      var dev = statValues[0/*ino*/].toString(32);\n      var ino = statValues[7/*ino*/].toString(32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return callback(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return callback(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n};\n\nfs.mkdtemp = function(prefix, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (!prefix || typeof prefix !== 'string')\n    throw new TypeError('filename prefix is required');\n  if (!nullCheck(prefix, callback)) {\n    return;\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.mkdtemp(prefix + 'XXXXXX', options.encoding, req);\n};\n\n\nfs.mkdtempSync = function(prefix, options) {\n  if (!prefix || typeof prefix !== 'string')\n    throw new TypeError('filename prefix is required');\n  options = getOptions(options, {});\n  nullCheck(prefix);\n  return binding.mkdtemp(prefix + 'XXXXXX', options.encoding);\n};\n\n\nvar pool;\n\nfunction allocNewPool(poolSize) {\n  pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n\nfs.createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n};\n\nutil.inherits(ReadStream, Readable);\nfs.ReadStream = ReadStream;\n\nfunction ReadStream(path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n\n  // a little bit bigger buffer and water marks by default\n  options = copyObject(getOptions(options, {}));\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  Readable.call(this, options);\n\n  handleError((this.path = getPathFromURL(path)));\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = undefined;\n  this.bytesRead = 0;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('\"start\" option must be a Number');\n    }\n    if (this.end === undefined) {\n      this.end = Infinity;\n    } else if (typeof this.end !== 'number') {\n      throw new TypeError('\"end\" option must be a Number');\n    }\n\n    if (this.start > this.end) {\n      throw new Error('\"start\" option must be <= \"end\" option');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  this.on('end', function() {\n    if (this.autoClose) {\n      this.destroy();\n    }\n  });\n}\n\nfs.FileReadStream = fs.ReadStream; // support the legacy name\n\nReadStream.prototype.open = function() {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n      return;\n    }\n\n    self.fd = fd;\n    self.emit('open', fd);\n    // start the flow of data.\n    self.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._read(n);\n    });\n\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    allocNewPool(this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (this.pos !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  var self = this;\n  fs.read(this.fd, pool, pool.used, toRead, this.pos, onread);\n\n  // move the pool positions, and internal position for reading.\n  if (this.pos !== undefined)\n    this.pos += toRead;\n  pool.used += toRead;\n\n  function onread(er, bytesRead) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n    } else {\n      var b = null;\n      if (bytesRead > 0) {\n        self.bytesRead += bytesRead;\n        b = thisPool.slice(start, start + bytesRead);\n      }\n\n      self.push(b);\n    }\n  }\n};\n\n\nReadStream.prototype._destroy = function(err, cb) {\n  this.close(function(err2) {\n    cb(err || err2);\n  });\n};\n\n\nReadStream.prototype.close = function(cb) {\n  if (cb)\n    this.once('close', cb);\n\n  if (this.closed || typeof this.fd !== 'number') {\n    if (typeof this.fd !== 'number') {\n      this.once('open', closeOnOpen);\n      return;\n    }\n    return process.nextTick(() => this.emit('close'));\n  }\n\n  this.closed = true;\n\n  fs.close(this.fd, (er) => {\n    if (er)\n      this.emit('error', er);\n    else\n      this.emit('close');\n  });\n\n  this.fd = null;\n};\n\n// needed because as it will be called with arguments\n// that does not match this.close() signature\nfunction closeOnOpen(fd) {\n  this.close();\n}\n\nfs.createWriteStream = function(path, options) {\n  return new WriteStream(path, options);\n};\n\nutil.inherits(WriteStream, Writable);\nfs.WriteStream = WriteStream;\nfunction WriteStream(path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path, options);\n\n  options = copyObject(getOptions(options, {}));\n\n  Writable.call(this, options);\n\n  handleError((this.path = getPathFromURL(path)));\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;\n  this.pos = undefined;\n  this.bytesWritten = 0;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('\"start\" option must be a Number');\n    }\n    if (this.start < 0) {\n      throw new Error('\"start\" must be >= zero');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', function() {\n    if (this.autoClose) {\n      this.close();\n    }\n  });\n}\n\nfs.FileWriteStream = fs.WriteStream; // support the legacy name\n\n\nWriteStream.prototype.open = function() {\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      if (this.autoClose) {\n        this.destroy();\n      }\n      this.emit('error', er);\n      return;\n    }\n\n    this.fd = fd;\n    this.emit('open', fd);\n  }.bind(this));\n};\n\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!(data instanceof Buffer))\n    return this.emit('error', new Error('Invalid data'));\n\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n\n  var self = this;\n  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += data.length;\n};\n\n\nfunction writev(fd, chunks, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to chunks so that they can't be GC'ed too soon.\n    callback(err, written || 0, chunks);\n  }\n\n  const req = new FSReqWrap();\n  req.oncomplete = wrapper;\n  binding.writeBuffers(fd, chunks, position, req);\n}\n\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n\n  const self = this;\n  const len = data.length;\n  const chunks = new Array(len);\n  var size = 0;\n\n  for (var i = 0; i < len; i++) {\n    var chunk = data[i].chunk;\n\n    chunks[i] = chunk;\n    size += chunk.length;\n  }\n\n  writev(this.fd, chunks, this.pos, function(er, bytes) {\n    if (er) {\n      self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += size;\n};\n\n\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = ReadStream.prototype.close;\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\n// SyncWriteStream is internal. DO NOT USE.\n// This undocumented API was never intended to be made public.\nvar SyncWriteStream = internalFS.SyncWriteStream;\nObject.defineProperty(fs, 'SyncWriteStream', {\n  configurable: true,\n  get: internalUtil.deprecate(() => SyncWriteStream,\n                              'fs.SyncWriteStream is deprecated.', 'DEP0061'),\n  set: internalUtil.deprecate((val) => { SyncWriteStream = val; },\n                              'fs.SyncWriteStream is deprecated.', 'DEP0061')\n});\n\n});",
      "pkgUrl": "(system)"
    },
    {
      "id": "22",
      "url": "bootstrap_node.js",
      "source": "// Hello, and welcome to hacking node.js!\n//\n// This file is invoked by node::LoadEnvironment in src/node.cc, and is\n// responsible for bootstrapping the node.js core. As special caution is given\n// to the performance of the startup process, many dependencies are invoked\n// lazily.\n\n'use strict';\n\n(function(process) {\n\n  function startup() {\n    const EventEmitter = NativeModule.require('events');\n    process._eventsCount = 0;\n\n    const origProcProto = Object.getPrototypeOf(process);\n    Object.setPrototypeOf(process, Object.create(EventEmitter.prototype, {\n      constructor: Object.getOwnPropertyDescriptor(origProcProto, 'constructor')\n    }));\n\n    EventEmitter.call(process);\n\n    setupProcessObject();\n\n    // do this good and early, since it handles errors.\n    setupProcessFatal();\n\n    setupProcessICUVersions();\n\n    setupGlobalVariables();\n    if (!process._noBrowserGlobals) {\n      setupGlobalTimeouts();\n      setupGlobalConsole();\n    }\n\n    const _process = NativeModule.require('internal/process');\n\n    _process.setup_hrtime();\n    _process.setup_cpuUsage();\n    _process.setupMemoryUsage();\n    _process.setupConfig(NativeModule._source);\n    NativeModule.require('internal/process/warning').setup();\n    NativeModule.require('internal/process/next_tick').setup();\n    NativeModule.require('internal/process/stdio').setup();\n    _process.setupKillAndExit();\n    _process.setupSignalHandlers();\n    if (global.__coverage__)\n      NativeModule.require('internal/process/write-coverage').setup();\n\n    // Do not initialize channel in debugger agent, it deletes env variable\n    // and the main thread won't see it.\n    if (process.argv[1] !== '--debug-agent')\n      _process.setupChannel();\n\n    _process.setupRawDebug();\n\n    // Ensure setURLConstructor() is called before the native\n    // URL::ToObject() method is used.\n    NativeModule.require('internal/url');\n\n    Object.defineProperty(process, 'argv0', {\n      enumerable: true,\n      configurable: false,\n      value: process.argv[0]\n    });\n    process.argv[0] = process.execPath;\n\n    // Handle `--debug*` deprecation and invalidation\n    if (process._invalidDebug) {\n      process.emitWarning(\n        '`node --debug` and `node --debug-brk` are invalid. ' +\n        'Please use `node --inspect` or `node --inspect-brk` instead.',\n        'DeprecationWarning', 'DEP0062', startup, true);\n      process.exit(9);\n    } else if (process._deprecatedDebugBrk) {\n      process.emitWarning(\n        '`node --inspect --debug-brk` is deprecated. ' +\n        'Please use `node --inspect-brk` instead.',\n        'DeprecationWarning', 'DEP0062', startup, true);\n    }\n\n    // There are various modes that Node can run in. The most common two\n    // are running from a script and running the REPL - but there are a few\n    // others like the debugger or running --eval arguments. Here we decide\n    // which mode we run in.\n\n    if (NativeModule.exists('_third_party_main')) {\n      // To allow people to extend Node in different ways, this hook allows\n      // one to drop a file lib/_third_party_main.js into the build\n      // directory which will be executed instead of Node's normal loading.\n      process.nextTick(function() {\n        NativeModule.require('_third_party_main');\n      });\n\n    } else if (process.argv[1] === 'inspect' || process.argv[1] === 'debug') {\n      if (process.argv[1] === 'debug') {\n        process.emitWarning(\n          '`node debug` is deprecated. Please use `node inspect` instead.',\n          'DeprecationWarning', 'DEP0068');\n      }\n\n      // Start the debugger agent\n      process.nextTick(function() {\n        NativeModule.require('node-inspect/lib/_inspect').start();\n      });\n\n    } else if (process.argv[1] === '--remote_debugging_server') {\n      // Start the debugging server\n      NativeModule.require('internal/inspector/remote_debugging_server');\n\n    } else if (process.argv[1] === '--debug-agent') {\n      // Start the debugger agent\n      NativeModule.require('_debug_agent').start();\n\n    } else if (process.profProcess) {\n      NativeModule.require('internal/v8_prof_processor');\n\n    } else {\n      // There is user code to be run\n\n      // If this is a worker in cluster mode, start up the communication\n      // channel. This needs to be done before any user code gets executed\n      // (including preload modules).\n      if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n        const cluster = NativeModule.require('cluster');\n        cluster._setupWorker();\n\n        // Make sure it's not accidentally inherited by child processes.\n        delete process.env.NODE_UNIQUE_ID;\n      }\n\n      if (process._eval != null && !process._forceRepl) {\n        // User passed '-e' or '--eval' arguments to Node without '-i' or\n        // '--interactive'\n        preloadModules();\n\n        const internalModule = NativeModule.require('internal/module');\n        internalModule.addBuiltinLibsToObject(global);\n        evalScript('[eval]');\n      } else if (process.argv[1] && process.argv[1] !== '-') {\n        // make process.argv[1] into a full path\n        const path = NativeModule.require('path');\n        process.argv[1] = path.resolve(process.argv[1]);\n\n        const Module = NativeModule.require('module');\n\n        // check if user passed `-c` or `--check` arguments to Node.\n        if (process._syntax_check_only != null) {\n          const fs = NativeModule.require('fs');\n          // read the source\n          const filename = Module._resolveFilename(process.argv[1]);\n          var source = fs.readFileSync(filename, 'utf-8');\n          checkScriptSyntax(source, filename);\n          process.exit(0);\n        }\n\n        preloadModules();\n        Module.runMain();\n      } else {\n        preloadModules();\n        // If -i or --interactive were passed, or stdin is a TTY.\n        if (process._forceRepl || NativeModule.require('tty').isatty(0)) {\n          // REPL\n          const cliRepl = NativeModule.require('internal/repl');\n          cliRepl.createInternalRepl(process.env, function(err, repl) {\n            if (err) {\n              throw err;\n            }\n            repl.on('exit', function() {\n              if (repl._flushing) {\n                repl.pause();\n                return repl.once('flushHistory', function() {\n                  process.exit();\n                });\n              }\n              process.exit();\n            });\n          });\n\n          if (process._eval != null) {\n            // User passed '-e' or '--eval'\n            evalScript('[eval]');\n          }\n        } else {\n          // Read all of stdin - execute it.\n          process.stdin.setEncoding('utf8');\n\n          var code = '';\n          process.stdin.on('data', function(d) {\n            code += d;\n          });\n\n          process.stdin.on('end', function() {\n            if (process._syntax_check_only != null) {\n              checkScriptSyntax(code, '[stdin]');\n            } else {\n              process._eval = code;\n              evalScript('[stdin]');\n            }\n          });\n        }\n      }\n    }\n  }\n\n  function setupProcessObject() {\n    process._setupProcessObject(pushValueToArray);\n\n    function pushValueToArray() {\n      for (var i = 0; i < arguments.length; i++)\n        this.push(arguments[i]);\n    }\n  }\n\n  function setupGlobalVariables() {\n    Object.defineProperty(global, Symbol.toStringTag, {\n      value: 'global',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    global.process = process;\n    const util = NativeModule.require('util');\n\n    function makeGetter(name) {\n      return util.deprecate(function() {\n        return this;\n      }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n    }\n\n    function makeSetter(name) {\n      return util.deprecate(function(value) {\n        Object.defineProperty(this, name, {\n          configurable: true,\n          writable: true,\n          enumerable: true,\n          value: value\n        });\n      }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n    }\n\n    Object.defineProperties(global, {\n      GLOBAL: {\n        configurable: true,\n        get: makeGetter('GLOBAL'),\n        set: makeSetter('GLOBAL')\n      },\n      root: {\n        configurable: true,\n        get: makeGetter('root'),\n        set: makeSetter('root')\n      }\n    });\n\n    global.Buffer = NativeModule.require('buffer').Buffer;\n    process.domain = null;\n    process._exiting = false;\n  }\n\n  function setupGlobalTimeouts() {\n    const timers = NativeModule.require('timers');\n    global.clearImmediate = timers.clearImmediate;\n    global.clearInterval = timers.clearInterval;\n    global.clearTimeout = timers.clearTimeout;\n    global.setImmediate = timers.setImmediate;\n    global.setInterval = timers.setInterval;\n    global.setTimeout = timers.setTimeout;\n  }\n\n  function setupGlobalConsole() {\n    const originalConsole = global.console;\n    let console;\n    Object.defineProperty(global, 'console', {\n      configurable: true,\n      enumerable: true,\n      get: function() {\n        if (!console) {\n          console = originalConsole === undefined ?\n              NativeModule.require('console') :\n              installInspectorConsole(originalConsole);\n        }\n        return console;\n      }\n    });\n  }\n\n  function installInspectorConsole(globalConsole) {\n    const wrappedConsole = NativeModule.require('console');\n    const inspector = process.binding('inspector');\n    const config = {};\n    for (const key of Object.keys(wrappedConsole)) {\n      if (!globalConsole.hasOwnProperty(key))\n        continue;\n      // If global console has the same method as inspector console,\n      // then wrap these two methods into one. Native wrapper will preserve\n      // the original stack.\n      wrappedConsole[key] = inspector.consoleCall.bind(wrappedConsole,\n                                                       globalConsole[key],\n                                                       wrappedConsole[key],\n                                                       config);\n    }\n    for (const key of Object.keys(globalConsole)) {\n      if (wrappedConsole.hasOwnProperty(key))\n        continue;\n      wrappedConsole[key] = globalConsole[key];\n    }\n    return wrappedConsole;\n  }\n\n  function setupProcessFatal() {\n    const async_wrap = process.binding('async_wrap');\n    // Arrays containing hook flags and ids for async_hook calls.\n    const { async_hook_fields, async_uid_fields } = async_wrap;\n    // Internal functions needed to manipulate the stack.\n    const { clearIdStack, popAsyncIds } = async_wrap;\n    const { kAfter, kCurrentAsyncId, kInitTriggerId } = async_wrap.constants;\n\n    process._fatalException = function(er) {\n      var caught;\n\n      // It's possible that kInitTriggerId was set for a constructor call that\n      // threw and was never cleared. So clear it now.\n      async_uid_fields[kInitTriggerId] = 0;\n\n      if (process.domain && process.domain._errorHandler)\n        caught = process.domain._errorHandler(er);\n\n      if (!caught)\n        caught = process.emit('uncaughtException', er);\n\n      // If someone handled it, then great.  otherwise, die in C++ land\n      // since that means that we'll exit the process, emit the 'exit' event\n      if (!caught) {\n        try {\n          if (!process._exiting) {\n            process._exiting = true;\n            process.emit('exit', 1);\n          }\n        } catch (er) {\n          // nothing to be done about it at this point.\n        }\n\n      } else {\n        // If we handled an error, then make sure any ticks get processed\n        NativeModule.require('timers').setImmediate(process._tickCallback);\n\n        // Emit the after() hooks now that the exception has been handled.\n        if (async_hook_fields[kAfter] > 0) {\n          do {\n            NativeModule.require('async_hooks').emitAfter(\n                async_uid_fields[kCurrentAsyncId]);\n          // popAsyncIds() returns true if there are more ids on the stack.\n          } while (popAsyncIds(async_uid_fields[kCurrentAsyncId]));\n        // Or completely empty the id stack.\n        } else {\n          clearIdStack();\n        }\n      }\n\n      return caught;\n    };\n  }\n\n  function setupProcessICUVersions() {\n    const icu = process.binding('config').hasIntl ?\n      process.binding('icu') : undefined;\n    if (!icu) return;  // no Intl/ICU: nothing to add here.\n    // With no argument, getVersion() returns a comma separated list\n    // of possible types.\n    const versionTypes = icu.getVersion().split(',');\n\n    function makeGetter(name) {\n      return () => {\n        // With an argument, getVersion(type) returns\n        // the actual version string.\n        const version = icu.getVersion(name);\n        // Replace the current getter with a new property.\n        delete process.versions[name];\n        Object.defineProperty(process.versions, name, {\n          value: version,\n          writable: false,\n          enumerable: true\n        });\n        return version;\n      };\n    }\n\n    for (var n = 0; n < versionTypes.length; n++) {\n      var name = versionTypes[n];\n      Object.defineProperty(process.versions, name, {\n        configurable: true,\n        enumerable: true,\n        get: makeGetter(name)\n      });\n    }\n  }\n\n  function tryGetCwd(path) {\n    var threw = true;\n    var cwd;\n    try {\n      cwd = process.cwd();\n      threw = false;\n    } finally {\n      if (threw) {\n        // getcwd(3) can fail if the current working directory has been deleted.\n        // Fall back to the directory name of the (absolute) executable path.\n        // It's not really correct but what are the alternatives?\n        return path.dirname(process.execPath);\n      }\n    }\n    return cwd;\n  }\n\n  function evalScript(name) {\n    const Module = NativeModule.require('module');\n    const path = NativeModule.require('path');\n    const cwd = tryGetCwd(path);\n\n    const module = new Module(name);\n    module.filename = path.join(cwd, name);\n    module.paths = Module._nodeModulePaths(cwd);\n    const body = process._eval;\n    const script = `global.__filename = ${JSON.stringify(name)};\\n` +\n                   'global.exports = exports;\\n' +\n                   'global.module = module;\\n' +\n                   'global.__dirname = __dirname;\\n' +\n                   'global.require = require;\\n' +\n                   'return require(\"vm\").runInThisContext(' +\n                   `${JSON.stringify(body)}, { filename: ` +\n                   `${JSON.stringify(name)}, displayErrors: true });\\n`;\n    const result = module._compile(script, `${name}-wrapper`);\n    if (process._print_eval) console.log(result);\n    // Handle any nextTicks added in the first tick of the program.\n    process._tickCallback();\n  }\n\n  // Load preload modules\n  function preloadModules() {\n    if (process._preload_modules) {\n      NativeModule.require('module')._preloadModules(process._preload_modules);\n    }\n  }\n\n  function checkScriptSyntax(source, filename) {\n    const Module = NativeModule.require('module');\n    const vm = NativeModule.require('vm');\n    const internalModule = NativeModule.require('internal/module');\n\n    // remove Shebang\n    source = internalModule.stripShebang(source);\n    // remove BOM\n    source = internalModule.stripBOM(source);\n    // wrap it\n    source = Module.wrap(source);\n    // compile the script, this will throw if it fails\n    new vm.Script(source, {displayErrors: true, filename});\n  }\n\n  // Below you find a minimal module system, which is used to load the node\n  // core modules found in lib/*.js. All core modules are compiled into the\n  // node binary, so they can be loaded faster.\n\n  const ContextifyScript = process.binding('contextify').ContextifyScript;\n  function runInThisContext(code, options) {\n    const script = new ContextifyScript(code, options);\n    return script.runInThisContext();\n  }\n\n  function NativeModule(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.exports = {};\n    this.loaded = false;\n    this.loading = false;\n  }\n\n  NativeModule._source = process.binding('natives');\n  NativeModule._cache = {};\n\n  NativeModule.require = function(id) {\n    if (id === 'native_module') {\n      return NativeModule;\n    }\n\n    const cached = NativeModule.getCached(id);\n    if (cached && (cached.loaded || cached.loading)) {\n      return cached.exports;\n    }\n\n    if (!NativeModule.exists(id)) {\n      // Model the error off the internal/errors.js model, but\n      // do not use that module given that it could actually be\n      // the one causing the error if there's a bug in Node.js\n      const err = new Error(`No such built-in module: ${id}`);\n      err.code = 'ERR_UNKNOWN_BUILTIN_MODULE';\n      err.name = 'Error [ERR_UNKNOWN_BUILTIN_MODULE]';\n      throw err;\n    }\n\n    process.moduleLoadList.push(`NativeModule ${id}`);\n\n    const nativeModule = new NativeModule(id);\n\n    nativeModule.cache();\n    nativeModule.compile();\n\n    return nativeModule.exports;\n  };\n\n  NativeModule.getCached = function(id) {\n    return NativeModule._cache[id];\n  };\n\n  NativeModule.exists = function(id) {\n    return NativeModule._source.hasOwnProperty(id);\n  };\n\n  const config = process.binding('config');\n\n  if (config.exposeInternals) {\n    NativeModule.nonInternalExists = NativeModule.exists;\n\n    NativeModule.isInternal = function(id) {\n      return false;\n    };\n  } else {\n    NativeModule.nonInternalExists = function(id) {\n      return NativeModule.exists(id) && !NativeModule.isInternal(id);\n    };\n\n    NativeModule.isInternal = function(id) {\n      return id.startsWith('internal/');\n    };\n  }\n\n\n  NativeModule.getSource = function(id) {\n    return NativeModule._source[id];\n  };\n\n  NativeModule.wrap = function(script) {\n    return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\n  };\n\n  NativeModule.wrapper = [\n    '(function (exports, require, module, __filename, __dirname) { ',\n    '\\n});'\n  ];\n\n  NativeModule.prototype.compile = function() {\n    var source = NativeModule.getSource(this.id);\n    source = NativeModule.wrap(source);\n\n    this.loading = true;\n\n    try {\n      const fn = runInThisContext(source, {\n        filename: this.filename,\n        lineOffset: 0,\n        displayErrors: true\n      });\n      fn(this.exports, NativeModule.require, this, this.filename);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n  };\n\n  NativeModule.prototype.cache = function() {\n    NativeModule._cache[this.id] = this;\n  };\n\n  startup();\n});\n",
      "pkgUrl": "(system)"
    },
    {
      "id": "41",
      "url": "path.js",
      "source": "(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst inspect = require('util').inspect;\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + inspect(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringWin32(path, allowAboveRoot) {\n  var res = '';\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47/*/*/ || code === 92/*\\*/)\n      break;\n    else\n      code = 47/*/*/;\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 ||\n            res.charCodeAt(res.length - 1) !== 46/*.*/ ||\n            res.charCodeAt(res.length - 2) !== 46/*.*/) {\n          if (res.length > 2) {\n            const start = res.length - 1;\n            var j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === 92/*\\*/)\n                break;\n            }\n            if (j !== start) {\n              if (j === -1)\n                res = '';\n              else\n                res = res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '\\\\..';\n          else\n            res = '..';\n        }\n      } else {\n        if (res.length > 0)\n          res += '\\\\' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46/*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47/*/*/)\n      break;\n    else\n      code = 47/*/*/;\n    if (code === 47/*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 ||\n            res.charCodeAt(res.length - 1) !== 46/*.*/ ||\n            res.charCodeAt(res.length - 2) !== 46/*.*/) {\n          if (res.length > 2) {\n            const start = res.length - 1;\n            var j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === 47/*/*/)\n                break;\n            }\n            if (j !== start) {\n              if (j === -1)\n                res = '';\n              else\n                res = res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46/*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    ((pathObject.name || '') + (pathObject.ext || ''));\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nconst win32 = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedDevice = '';\n    var resolvedTail = '';\n    var resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1; i--) {\n      var path;\n      if (i >= 0) {\n        path = arguments[i];\n      } else if (!resolvedDevice) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env['=' + resolvedDevice] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (path === undefined ||\n            path.slice(0, 3).toLowerCase() !==\n              resolvedDevice.toLowerCase() + '\\\\') {\n          path = resolvedDevice + '\\\\';\n        }\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      var len = path.length;\n      var rootEnd = 0;\n      var code = path.charCodeAt(0);\n      var device = '';\n      var isAbsolute = false;\n\n      // Try to match a root\n      if (len > 1) {\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Possible UNC root\n\n          // If we started with a separator, we know we at least have an\n          // absolute path of some kind (UNC or otherwise)\n          isAbsolute = true;\n\n          code = path.charCodeAt(1);\n          if (code === 47/*/*/ || code === 92/*\\*/) {\n            // Matched double path separator at beginning\n            var j = 2;\n            var last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code === 47/*/*/ || code === 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              const firstPart = path.slice(last, j);\n              // Matched!\n              last = j;\n              // Match 1 or more path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code !== 47/*/*/ && code !== 92/*\\*/)\n                  break;\n              }\n              if (j < len && j !== last) {\n                // Matched!\n                last = j;\n                // Match 1 or more non-path separators\n                for (; j < len; ++j) {\n                  code = path.charCodeAt(j);\n                  if (code === 47/*/*/ || code === 92/*\\*/)\n                    break;\n                }\n                if (j === len) {\n                  // We matched a UNC root only\n\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n                  rootEnd = j;\n                } else if (j !== last) {\n                  // We matched a UNC root with leftovers\n\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                  rootEnd = j;\n                }\n              }\n            }\n          } else {\n            rootEnd = 1;\n          }\n        } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                   (code >= 97/*a*/ && code <= 122/*z*/)) {\n          // Possible device root\n\n          code = path.charCodeAt(1);\n          if (path.charCodeAt(1) === 58/*:*/) {\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2) {\n              code = path.charCodeAt(2);\n              if (code === 47/*/*/ || code === 92/*\\*/) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n              }\n            }\n          }\n        }\n      } else if (code === 47/*/*/ || code === 92/*\\*/) {\n        // `path` contains just a path separator\n        rootEnd = 1;\n        isAbsolute = true;\n      }\n\n      if (device.length > 0 &&\n          resolvedDevice.length > 0 &&\n          device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n        // This path points to another device so it is not applicable\n        continue;\n      }\n\n      if (resolvedDevice.length === 0 && device.length > 0) {\n        resolvedDevice = device;\n      }\n      if (!resolvedAbsolute) {\n        resolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n        resolvedAbsolute = isAbsolute;\n      }\n\n      if (resolvedDevice.length > 0 && resolvedAbsolute) {\n        break;\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeStringWin32(resolvedTail, !resolvedAbsolute);\n\n    return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n           '.';\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    var rootEnd = 0;\n    var code = path.charCodeAt(0);\n    var device;\n    var isAbsolute = false;\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an absolute\n        // path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        code = path.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                // Return the normalized version of the UNC root since there\n                // is nothing left to process\n\n                return '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      // `path` contains just a path separator, exit early to avoid unnecessary\n      // work\n      return '\\\\';\n    }\n\n    code = path.charCodeAt(len - 1);\n    var trailingSeparator = (code === 47/*/*/ || code === 92/*\\*/);\n    var tail;\n    if (rootEnd < len)\n      tail = normalizeStringWin32(path.slice(rootEnd), !isAbsolute);\n    else\n      tail = '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 && trailingSeparator)\n      tail += '\\\\';\n    if (device === undefined) {\n      if (isAbsolute) {\n        if (tail.length > 0)\n          return '\\\\' + tail;\n        else\n          return '\\\\';\n      } else if (tail.length > 0) {\n        return tail;\n      } else {\n        return '';\n      }\n    } else {\n      if (isAbsolute) {\n        if (tail.length > 0)\n          return device + '\\\\' + tail;\n        else\n          return device + '\\\\';\n      } else if (tail.length > 0) {\n        return device + tail;\n      } else {\n        return device;\n      }\n    }\n  },\n\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return false;\n    var code = path.charCodeAt(0);\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      return true;\n    } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n               (code >= 97/*a*/ && code <= 122/*z*/)) {\n      // Possible device root\n\n      if (len > 2 && path.charCodeAt(1) === 58/*:*/) {\n        code = path.charCodeAt(2);\n        if (code === 47/*/*/ || code === 92/*\\*/)\n          return true;\n      }\n    }\n    return false;\n  },\n\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n\n    var joined;\n    var firstPart;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += '\\\\' + arg;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n    //var firstPart = paths[0];\n    var needsReplace = true;\n    var slashCount = 0;\n    var code = firstPart.charCodeAt(0);\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1) {\n        code = firstPart.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          ++slashCount;\n          if (firstLen > 2) {\n            code = firstPart.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              ++slashCount;\n            else {\n              // We matched a UNC path in the first part\n              needsReplace = false;\n            }\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      for (; slashCount < joined.length; ++slashCount) {\n        code = joined.charCodeAt(slashCount);\n        if (code !== 47/*/*/ && code !== 92/*\\*/)\n          break;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = '\\\\' + joined.slice(slashCount);\n    }\n\n    return win32.normalize(joined);\n  },\n\n\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to)\n      return '';\n\n    var fromOrig = win32.resolve(from);\n    var toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    var fromStart = 0;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 92/*\\*/)\n        break;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    var fromEnd = from.length;\n    for (; fromEnd - 1 > fromStart; --fromEnd) {\n      if (from.charCodeAt(fromEnd - 1) !== 92/*\\*/)\n        break;\n    }\n    var fromLen = (fromEnd - fromStart);\n\n    // Trim any leading backslashes\n    var toStart = 0;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 92/*\\*/)\n        break;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    var toEnd = to.length;\n    for (; toEnd - 1 > toStart; --toEnd) {\n      if (to.charCodeAt(toEnd - 1) !== 92/*\\*/)\n        break;\n    }\n    var toLen = (toEnd - toStart);\n\n    // Compare paths to find the longest common path from root\n    var length = (fromLen < toLen ? fromLen : toLen);\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 92/*\\*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n            return toOrig.slice(toStart + i + 1);\n          } else if (i === 2) {\n            // We get here if `from` is the device root.\n            // For example: from='C:\\\\'; to='C:\\\\foo'\n            return toOrig.slice(toStart + i);\n          }\n        }\n        if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 92/*\\*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n            lastCommonSep = i;\n          } else if (i === 2) {\n            // We get here if `to` is the device root.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n            lastCommonSep = 3;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 92/*\\*/)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n    if (i !== length && lastCommonSep === -1) {\n      return toOrig;\n    }\n\n    var out = '';\n    if (lastCommonSep === -1)\n      lastCommonSep = 0;\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 92/*\\*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '\\\\..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n    else {\n      toStart += lastCommonSep;\n      if (toOrig.charCodeAt(toStart) === 92/*\\*/)\n        ++toStart;\n      return toOrig.slice(toStart, toEnd);\n    }\n  },\n\n\n  _makeLong: function _makeLong(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string')\n      return path;\n\n    if (path.length === 0) {\n      return '';\n    }\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length >= 3) {\n      var code = resolvedPath.charCodeAt(0);\n      if (code === 92/*\\*/) {\n        // Possible UNC root\n\n        if (resolvedPath.charCodeAt(1) === 92/*\\*/) {\n          code = resolvedPath.charCodeAt(2);\n          if (code !== 63/*?*/ && code !== 46/*.*/) {\n            // Matched non-long UNC root, convert the path to a long UNC path\n            return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        if (resolvedPath.charCodeAt(1) === 58/*:*/ &&\n            resolvedPath.charCodeAt(2) === 92/*\\*/) {\n          // Matched device root, convert the path to a long UNC path\n          return '\\\\\\\\?\\\\' + resolvedPath;\n        }\n      }\n    }\n\n    return path;\n  },\n\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    var rootEnd = -1;\n    var end = -1;\n    var matchedSlash = true;\n    var offset = 0;\n    var code = path.charCodeAt(0);\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        rootEnd = offset = 1;\n\n        code = path.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                return path;\n              }\n              if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                // Offset by 1 to include the separator after the UNC root to\n                // treat it as a \"normal root\" on top of a (UNC) root\n                rootEnd = offset = j + 1;\n              }\n            }\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          rootEnd = offset = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              rootEnd = offset = 3;\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      return path[0];\n    }\n\n    for (var i = len - 1; i >= offset; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n      else\n        end = rootEnd;\n    }\n    return path.slice(0, end);\n  },\n\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string')\n      throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2) {\n      const drive = path.charCodeAt(0);\n      if ((drive >= 65/*A*/ && drive <= 90/*Z*/) ||\n          (drive >= 97/*a*/ && drive <= 122/*z*/)) {\n        if (path.charCodeAt(1) === 58/*:*/)\n          start = 2;\n      }\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path)\n        return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1)\n        return '';\n      return path.slice(start, end);\n    }\n  },\n\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError(\n        `Parameter \"pathObject\" must be an object, not ${typeof pathObject}`\n      );\n    }\n    return _format('\\\\', pathObject);\n  },\n\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n\n    var len = path.length;\n    var rootEnd = 0;\n    var code = path.charCodeAt(0);\n    var isAbsolute = false;\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        isAbsolute = true;\n\n        code = path.charCodeAt(1);\n        rootEnd = 1;\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                rootEnd = j + 1;\n              }\n            }\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          rootEnd = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/) {\n              if (len === 3) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path.slice(0, 3);\n                return ret;\n              }\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          } else {\n            // `path` contains just a drive root, exit early to avoid\n            // unnecessary work\n            ret.root = ret.dir = path.slice(0, 2);\n            return ret;\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      ret.root = ret.dir = path[0];\n      return ret;\n    }\n\n    if (rootEnd > 0)\n      ret.root = path.slice(0, rootEnd);\n\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(rootEnd, end);\n        else\n          ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(rootEnd, startDot);\n        ret.base = path.slice(rootEnd, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0)\n      ret.dir = path.slice(0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = path.slice(0, rootEnd);\n\n    return ret;\n  },\n\n\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\n\n\nconst posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47/*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute = path.charCodeAt(0) === 47/*/*/;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === 47/*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute)\n      path = '.';\n    if (path.length > 0 && trailingSeparator)\n      path += '/';\n\n    if (isAbsolute)\n      return '/' + path;\n    return path;\n  },\n\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47/*/*/;\n  },\n\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to)\n      return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47/*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = (fromEnd - fromStart);\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47/*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = (toEnd - toStart);\n\n    // Compare paths to find the longest common path from root\n    var length = (fromLen < toLen ? fromLen : toLen);\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47/*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47/*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47/*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47/*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47/*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0)\n      return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = (code === 47/*/*/);\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return path.slice(0, end);\n  },\n\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string')\n      throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path)\n        return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47/*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1)\n        return '';\n      return path.slice(start, end);\n    }\n  },\n\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError(\n        `Parameter \"pathObject\" must be an object, not ${typeof pathObject}`\n      );\n    }\n    return _format('/', pathObject);\n  },\n\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = (code === 47/*/*/);\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(1, end);\n        else\n          ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0)\n      ret.dir = path.slice(0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  },\n\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n\nif (process.platform === 'win32')\n  module.exports = win32;\nelse\n  module.exports = posix;\n\n});",
      "pkgUrl": "(system)"
    },
    {
      "id": "7",
      "url": "native string.js",
      "pkgUrl": "(system)"
    },
    {
      "id": "38",
      "url": "fs.js",
      "source": "(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst util = require('util');\nconst {\n  hexTable,\n  isHexTable\n} = require('internal/querystring');\n\nconst { getConstructorOf } = require('internal/util');\nconst errors = require('internal/errors');\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII,\n  domainToUnicode: _domainToUnicode,\n  encodeAuth,\n  toUSVString: _toUSVString,\n  parse: _parse,\n  setURLConstructor,\n  URL_FLAGS_CANNOT_BE_BASE,\n  URL_FLAGS_HAS_FRAGMENT,\n  URL_FLAGS_HAS_HOST,\n  URL_FLAGS_HAS_PASSWORD,\n  URL_FLAGS_HAS_PATH,\n  URL_FLAGS_HAS_QUERY,\n  URL_FLAGS_HAS_USERNAME,\n  URL_FLAGS_SPECIAL,\n  kFragment,\n  kHost,\n  kHostname,\n  kPathStart,\n  kPort,\n  kQuery,\n  kSchemeStart\n} = process.binding('url');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = Object.getPrototypeOf(\n  Object.getPrototypeOf([][Symbol.iterator]())\n);\n\nconst unpairedSurrogateRe =\n    /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5, `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = unpairedSurrogateRe.exec(str);\n  if (!match)\n    return str;\n  return _toUSVString(str, match.index);\n}\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme, host, port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard, with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nfunction onParseComplete(flags, protocol, username, password,\n                         host, port, path, query, fragment) {\n  var ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams], query);\n}\n\nfunction onParseError(flags, input) {\n  const error = new errors.TypeError('ERR_INVALID_URL', input);\n  error.input = input;\n  throw error;\n}\n\n// Reused by URL constructor and URL#href setter.\nfunction parse(url, input, base) {\n  const base_context = base ? base[context] : undefined;\n  url[context] = new URLContext();\n  _parse(input.trim(), -1, base_context, undefined,\n         onParseComplete.bind(url), onParseError);\n}\n\nfunction onParseProtocolComplete(flags, protocol, username, password,\n                                 host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n}\n\nfunction onParseHostComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n  if (port !== null)\n    ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags, protocol, username, password,\n                                 host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  this[context].port = port;\n}\n\nfunction onParsePathComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags, protocol, username, password,\n                               host, port, path, query, fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  this[context].fragment = fragment;\n}\n\nclass URL {\n  constructor(input, base) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    if (base !== undefined &&\n        (!base[searchParams] || !base[searchParams][searchParams])) {\n      base = new URL(base);\n    }\n    parse(this, input, base);\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host, scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [util.inspect.custom](depth, opts) {\n    if (this == null ||\n        Object.getPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return opts.stylize('[Object]', 'special');\n\n    var ctor = getConstructorOf(this);\n\n    var obj = Object.create({\n      constructor: ctor === null ? URL : ctor\n    });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return util.inspect(obj, opts);\n  }\n}\n\nObject.defineProperties(URL.prototype, {\n  [kFormat]: {\n    enumerable: false,\n    configurable: false,\n    // eslint-disable-next-line func-name-matching\n    value: function format(options) {\n      if (options && typeof options !== 'object')\n        throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');\n      options = Object.assign({\n        fragment: true,\n        unicode: false,\n        search: true,\n        auth: true\n      }, options);\n      const ctx = this[context];\n      var ret = ctx.scheme;\n      if (ctx.host !== null) {\n        ret += '//';\n        const has_username = ctx.username !== '';\n        const has_password = ctx.password !== '';\n        if (options.auth && (has_username || has_password)) {\n          if (has_username)\n            ret += ctx.username;\n          if (has_password)\n            ret += `:${ctx.password}`;\n          ret += '@';\n        }\n        ret += options.unicode ?\n          domainToUnicode(this.host) : this.host;\n      } else if (ctx.scheme === 'file:') {\n        ret += '//';\n      }\n      if (this.pathname)\n        ret += this.pathname;\n      if (options.search && ctx.query !== null)\n        ret += `?${ctx.query}`;\n      if (options.fragment && ctx.fragment !== null)\n        ret += `#${ctx.fragment}`;\n      return ret;\n    }\n  },\n  [Symbol.toStringTag]: {\n    configurable: true,\n    value: 'URL'\n  },\n  toString: {\n    // https://heycam.github.io/webidl/#es-stringifier\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    // eslint-disable-next-line func-name-matching\n    value: function toString() {\n      return this[kFormat]({});\n    }\n  },\n  href: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[kFormat]({});\n    },\n    set(input) {\n      // toUSVString is not needed.\n      input = `${input}`;\n      parse(this, input);\n    }\n  },\n  origin: {  // readonly\n    enumerable: true,\n    configurable: true,\n    get() {\n      // Refs: https://url.spec.whatwg.org/#concept-url-origin\n      const ctx = this[context];\n      switch (ctx.scheme) {\n        case 'blob:':\n          if (ctx.path.length > 0) {\n            try {\n              return (new URL(ctx.path[0])).origin;\n            } catch (err) {\n              // fall through... do nothing\n            }\n          }\n          return kOpaqueOrigin;\n        case 'ftp:':\n        case 'gopher:':\n        case 'http:':\n        case 'https:':\n        case 'ws:':\n        case 'wss:':\n          return serializeTupleOrigin(ctx.scheme, ctx.host, ctx.port);\n      }\n      return kOpaqueOrigin;\n    }\n  },\n  protocol: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].scheme;\n    },\n    set(scheme) {\n      // toUSVString is not needed.\n      scheme = `${scheme}`;\n      if (scheme.length === 0)\n        return;\n      const ctx = this[context];\n      if (ctx.scheme === 'file:' &&\n          (ctx.host === '' || ctx.host === null)) {\n        return;\n      }\n      _parse(scheme, kSchemeStart, null, ctx,\n             onParseProtocolComplete.bind(this));\n    }\n  },\n  username: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].username;\n    },\n    set(username) {\n      // toUSVString is not needed.\n      username = `${username}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (username === '') {\n        ctx.username = '';\n        ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n        return;\n      }\n      ctx.username = encodeAuth(username);\n      ctx.flags |= URL_FLAGS_HAS_USERNAME;\n    }\n  },\n  password: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].password;\n    },\n    set(password) {\n      // toUSVString is not needed.\n      password = `${password}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (password === '') {\n        ctx.password = '';\n        ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n        return;\n      }\n      ctx.password = encodeAuth(password);\n      ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n    }\n  },\n  host: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const ctx = this[context];\n      var ret = ctx.host || '';\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n      return ret;\n    },\n    set(host) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      host = `${host}`;\n      if (this[cannotBeBase]) {\n        // Cannot set the host if cannot-be-base is set\n        return;\n      }\n      _parse(host, kHost, null, ctx, onParseHostComplete.bind(this));\n    }\n  },\n  hostname: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].host || '';\n    },\n    set(host) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      host = `${host}`;\n      if (this[cannotBeBase]) {\n        // Cannot set the host if cannot-be-base is set\n        return;\n      }\n      _parse(host, kHostname, null, ctx, onParseHostnameComplete.bind(this));\n    }\n  },\n  port: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const port = this[context].port;\n      return port === null ? '' : String(port);\n    },\n    set(port) {\n      // toUSVString is not needed.\n      port = `${port}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (port === '') {\n        ctx.port = null;\n        return;\n      }\n      _parse(port, kPort, null, ctx, onParsePortComplete.bind(this));\n    }\n  },\n  pathname: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const ctx = this[context];\n      if (this[cannotBeBase])\n        return ctx.path[0];\n      if (ctx.path.length === 0)\n        return '';\n      return `/${ctx.path.join('/')}`;\n    },\n    set(path) {\n      // toUSVString is not needed.\n      path = `${path}`;\n      if (this[cannotBeBase])\n        return;\n      _parse(path, kPathStart, null, this[context],\n             onParsePathComplete.bind(this));\n    }\n  },\n  search: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const { query } = this[context];\n      if (query === null || query === '')\n        return '';\n      return `?${query}`;\n    },\n    set(search) {\n      const ctx = this[context];\n      search = toUSVString(search);\n      if (search === '') {\n        ctx.query = null;\n        ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n      } else {\n        if (search[0] === '?') search = search.slice(1);\n        ctx.query = '';\n        ctx.flags |= URL_FLAGS_HAS_QUERY;\n        if (search) {\n          _parse(search, kQuery, null, ctx, onParseSearchComplete.bind(this));\n        }\n      }\n      initSearchParams(this[searchParams], search);\n    }\n  },\n  searchParams: {  // readonly\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[searchParams];\n    }\n  },\n  hash: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const { fragment } = this[context];\n      if (fragment === null || fragment === '')\n        return '';\n      return `#${fragment}`;\n    },\n    set(hash) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      hash = `${hash}`;\n      if (!hash) {\n        ctx.fragment = null;\n        ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n        return;\n      }\n      if (hash[0] === '#') hash = hash.slice(1);\n      ctx.fragment = '';\n      ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n      _parse(hash, kFragment, null, ctx, onParseHashComplete.bind(this));\n    }\n  },\n  toJSON: {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    // eslint-disable-next-line func-name-matching\n    value: function toJSON() {\n      return this[kFormat]({});\n    }\n  }\n});\n\nfunction update(url, params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url, init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  var pairStart = 0;\n  var lastPos = 0;\n  var seenSep = false;\n  var buf = '';\n  var encoded = false;\n  var encodeCheck = 0;\n  var i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = qs.charCodeAt(i);\n\n    // Try matching key/value pair separator\n    if (code === 38/*&*/) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key, add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === 61/*=*/) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === 43/*+*/) {\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === 37/*%*/) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        // eslint-disable-next-line no-extra-boolean-cast\n        if (!!isHexTable[code]) {\n          if (++encodeCheck === 3)\n            encoded = true;\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += qs.slice(lastPos, i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  out.push(buf);\n\n  // If `buf` is the key, add an empty value.\n  if (!seenSep)\n    out.push('');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = [\n//0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00 - 0x0F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x10 - 0x1F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, // 0x20 - 0x2F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 0x30 - 0x3F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x40 - 0x4F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 0x50 - 0x5F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x60 - 0x6F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 0x70 - 0x7F\n];\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\nfunction escapeParam(str) {\n  const len = str.length;\n  if (len === 0)\n    return '';\n\n  var out = '';\n  var lastPos = 0;\n\n  for (var i = 0; i < len; i++) {\n    var c = str.charCodeAt(i);\n\n    // ASCII\n    if (c < 0x80) {\n      if (noEscape[c] === 1)\n        continue;\n      if (lastPos < i)\n        out += str.slice(lastPos, i);\n      lastPos = i + 1;\n      out += paramHexTable[c];\n      continue;\n    }\n\n    if (lastPos < i)\n      out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += paramHexTable[0xC0 | (c >> 6)] +\n             paramHexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += paramHexTable[0xE0 | (c >> 12)] +\n             paramHexTable[0x80 | ((c >> 6) & 0x3F)] +\n             paramHexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    var c2;\n    if (i < len)\n      c2 = str.charCodeAt(i) & 0x3FF;\n    else {\n      // This branch should never happen because all URLSearchParams entries\n      // should already be converted to USVString. But, included for\n      // completion's sake anyway.\n      c2 = 0;\n    }\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n    out += paramHexTable[0xF0 | (c >> 18)] +\n           paramHexTable[0x80 | ((c >> 12) & 0x3F)] +\n           paramHexTable[0x80 | ((c >> 6) & 0x3F)] +\n           paramHexTable[0x80 | (c & 0x3F)];\n  }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < len)\n    return out + str.slice(lastPos);\n  return out;\n}\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  var output = `${escapeParam(array[0])}=${escapeParam(array[1])}`;\n  for (var i = 2; i < len; i += 2)\n    output += `&${escapeParam(array[i])}=${escapeParam(array[i + 1])}`;\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto, classStr, obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  Object.defineProperty(proto, Symbol.toStringTag, {\n    writable: false,\n    enumerable: false,\n    configurable: true,\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of Object.keys(obj)) {\n    Object.defineProperty(proto, key, {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n  for (const key of Object.getOwnPropertySymbols(obj)) {\n    Object.defineProperty(proto, key, {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is '', but as undefined and '' have\n  // the same result, undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if ((typeof init === 'object' && init !== null) ||\n               typeof init === 'function') {\n      const method = init[Symbol.iterator];\n      if (method === this[Symbol.iterator]) {\n        // While the spec does not have this branch, we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new errors.TypeError('ERR_ARG_NOT_ITERABLE', 'Query pairs');\n        }\n\n        // sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\n              pair === null ||\n              typeof pair[Symbol.iterator] !== 'function') {\n            throw new errors.TypeError('ERR_INVALID_TUPLE', 'Each query pair',\n                                       '[name, value]');\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            convertedPair.push(toUSVString(element));\n          pairs.push(convertedPair);\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new errors.TypeError('ERR_INVALID_TUPLE', 'Each query pair',\n                                       '[name, value]');\n          }\n          this[searchParams].push(pair[0], pair[1]);\n        }\n      } else {\n        // record<USVString, USVString>\n        // Need to use reflection APIs for full spec compliance.\n        this[searchParams] = [];\n        const keys = Reflect.ownKeys(init);\n        for (var i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = Reflect.getOwnPropertyDescriptor(init, key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n            this[searchParams].push(typedKey, typedValue);\n          }\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this, init);\n    }\n\n    // \"associated url object\"\n    this[context] = null;\n  }\n\n  [util.inspect.custom](recurseTimes, ctx) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]', 'special');\n\n    var separator = ', ';\n    var innerOpts = Object.assign({}, ctx);\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    var innerInspect = (v) => util.inspect(v, innerOpts);\n\n    var list = this[searchParams];\n    var output = [];\n    for (var i = 0; i < list.length; i += 2)\n      output.push(`${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    var colorRe = /\\u001b\\[\\d\\d?m/g;\n    var length = output.reduce(\n      (prev, cur) => prev + cur.replace(colorRe, '').length + separator.length,\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n  ${output.join(',\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ${output.join(separator)} }`;\n    } else {\n      return `${this.constructor.name} {}`;\n    }\n  }\n}\n\n// for merge sort\nfunction merge(out, start, mid, end, lBuffer, rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  var l, r, o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\ndefineIDLClass(URLSearchParams.prototype, 'URLSearchParams', {\n  append(name, value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name', 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    this[searchParams].push(name, value);\n    update(this[context], this);\n  },\n\n  delete(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i, 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context], this);\n  },\n\n  get(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  },\n\n  getAll(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  },\n\n  has(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  set(name, value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name', 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`, in `list`, set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    var found = false;\n    for (var i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i, 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise, append a new name-value pair whose name is `name` and value\n    // is `value`, to `list`.\n    if (!found) {\n      list.push(name, value);\n    }\n\n    update(this[context], this);\n  },\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n    if (len <= 2) {\n      return;\n    }\n\n    // arbitrary number found through testing\n    if (len < 100) {\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (var i = 2; i < len; i += 2) {\n        var curKey = a[i];\n        var curVal = a[i + 1];\n        var j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (var step = 2; step < len; step *= 2) {\n        for (var start = 0; start < len - 2; start += 2 * step) {\n          var mid = start + step;\n          var end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a, start, mid, end, lBuffer, rBuffer);\n        }\n      }\n    }\n\n    update(this[context], this);\n  },\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'key+value');\n  },\n\n  forEach(callback, thisArg = undefined) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (typeof callback !== 'function') {\n      throw new errors.TypeError('ERR_INVALID_CALLBACK');\n    }\n\n    let list = this[searchParams];\n\n    var i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg, value, key, this);\n      // in case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  },\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'key');\n  },\n\n  values() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'value');\n  },\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return serializeParams(this[searchParams]);\n  }\n});\n\n// https://heycam.github.io/webidl/#es-iterable-entries\nObject.defineProperty(URLSearchParams.prototype, Symbol.iterator, {\n  writable: true,\n  configurable: true,\n  value: URLSearchParams.prototype.entries\n});\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target, kind) {\n  const iterator = Object.create(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = Object.create(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype, 'URLSearchParamsIterator', {\n  next() {\n    if (!this ||\n        Object.getPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParamsIterator');\n    }\n\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name, value];\n    }\n\n    return {\n      value: result,\n      done: false\n    };\n  },\n  [util.inspect.custom](recurseTimes, ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]', 'special');\n\n    const innerOpts = Object.assign({}, ctx);\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const output = target[searchParams].slice(index).reduce((prev, cur, i) => {\n      const key = i % 2 === 0;\n      if (kind === 'key' && key) {\n        prev.push(cur);\n      } else if (kind === 'value' && !key) {\n        prev.push(cur);\n      } else if (kind === 'key+value' && !key) {\n        prev.push([target[searchParams][index + i - 1], cur]);\n      }\n      return prev;\n    }, []);\n    const breakLn = util.inspect(output, innerOpts).includes('\\n');\n    const outputStrs = output.map((p) => util.inspect(p, innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${outputStrs.join(',\\n  ')}`;\n    } else {\n      outputStr = ` ${outputStrs.join(', ')}`;\n    }\n    return `${this[Symbol.toStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new errors.TypeError('ERR_MISSING_ARGS', 'domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new errors.TypeError('ERR_MISSING_ARGS', 'domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToOptions(url) {\n  var options = {\n    protocol: url.protocol,\n    hostname: url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname}${url.search}`,\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\nfunction getPathFromURLWin32(url) {\n  var hostname = url.hostname;\n  var pathname = url.pathname;\n  for (var n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      var third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        return new errors.TypeError(\n          'ERR_INVALID_FILE_URL_PATH',\n          'must not include encoded \\\\ or / characters');\n      }\n    }\n  }\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set, then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `//${domainToUnicode(hostname)}${pathname}`;\n  } else {\n    // Otherwise, it's a local path that requires a drive letter\n    var letter = pathname.codePointAt(1) | 0x20;\n    var sep = pathname[2];\n    if (letter < 97 || letter > 122 ||   // a..z A..Z\n        (sep !== ':')) {\n      return new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n                                  'must be absolute');\n    }\n    return pathname.slice(1);\n  }\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    return new errors.TypeError('ERR_INVALID_FILE_URL_HOST',\n                                `must be \"localhost\" or empty on ${platform}`);\n  }\n  var pathname = url.pathname;\n  for (var n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      var third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        return new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n                                    'must not include encoded / characters');\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction getPathFromURL(path) {\n  if (path == null || !path[searchParams] ||\n      !path[searchParams][searchParams]) {\n    return path;\n  }\n  if (path.protocol !== 'file:')\n    return new errors.TypeError('ERR_INVALID_URL_SCHEME', 'file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\nfunction NativeURL(ctx) {\n  this[context] = ctx;\n}\nNativeURL.prototype = URL.prototype;\n\nfunction constructUrl(flags, protocol, username, password,\n                      host, port, path, query, fragment) {\n  var ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  const url = new NativeURL(ctx);\n  url[searchParams] = new URLSearchParams();\n  url[searchParams][context] = url;\n  initSearchParams(url[searchParams], query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString,\n  getPathFromURL,\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  urlToOptions,\n  formatSymbol: kFormat,\n  searchParamsSymbol: searchParams\n};\n\n});",
      "pkgUrl": "(system)"
    },
    {
      "id": "69",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
      "source": "(function (exports, require, module, __filename, __dirname) { module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar Glob = require('./glob.js').Glob\nvar util = require('util')\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob"
    },
    {
      "id": "70",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/sync.js",
      "source": "(function (exports, require, module, __filename, __dirname) { exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = require(\"path\")\nvar minimatch = require(\"minimatch\")\nvar isAbsolute = require(\"path-is-absolute\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob"
    },
    {
      "id": "19",
      "url": "native i18n.js",
      "pkgUrl": "(system)"
    },
    {
      "id": "63",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob/common.js",
      "source": "(function (exports, require, module, __filename, __dirname) { module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob"
    },
    {
      "id": "110",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
      "source": "(function (exports, require, module, __filename, __dirname) { var removeComments = require('./_remove-comments')\nvar getSections = require('./_get-sections')\nvar parseSection = require('./_parse-section')\n\nmodule.exports = function parseArcFile(text) {\n  if (!text) throw Error('missing text')\n  var clean = removeComments(text)\n  var parts = getSections(clean).map(parseSection)\n  return parts.reduce((a,b)=> Object.assign({}, a, b))\n}\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer"
    },
    {
      "id": "112",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_get-sections.js",
      "source": "(function (exports, require, module, __filename, __dirname) { module.exports = function getSections(text) {\n  \n  if (!text.startsWith('@')) {\n    throw SyntaxError(`invalid_arc\nAn .arc text must have an opening @section.\n\n    `)\n  }\n\n  // splits text into array of arrays\n  var sections = text.split('@').filter(Boolean).map(c=> c.split(/\\r?\\n/).filter(Boolean).map(s=>s.trimRight()))\n  \n  // validates sections\n  sections.forEach(section=> {\n\n    // operate on a copy so we don't pollute the text\n    var clone = section.slice(0)\n\n    // validate the @section name (must not contain whitespace)\n    var name = clone.shift()\n    var bad = /\\s+/.test(name)\n    if (bad) {\n       throw SyntaxError(`invalid_section\n@sections must be a string of non whitespace characters.\n              \nInvalid value: \"${name}\"\n       `)  \n    }\n\n    // validates section values\n    var index = 0\n    var lastToken = false\n    clone.forEach(val=> {\n      // values must start with one or more non whitespace characters\n      var isText = /^\\S+/.test(val)\n      // console.log({val, isText})\n      if (!isText) {\n        var isDoubleSpaceFollowedByText = /\\s{2}\\S+/.test(val)\n        var followsSingleValueOrDouble = (typeof lastToken === 'string' && !/ /g.test(lastToken)) || /\\s{2}\\S+/.test(lastToken)\n        // console.log({isDoubleSpaceFollowedByText, followsSingleValue, val, lastToken})\n        if (!isDoubleSpaceFollowedByText) {\n          throw SyntaxError(`invalid_section_value\n@section values cannot start with whitespace.\n\nInvalid value: \"${val}\"\n          `)\n        }\n        else if (isDoubleSpaceFollowedByText && !followsSingleValueOrDouble) {\n          // if there is whitespace two spaces is allowed if it is following a simple single value\n          throw SyntaxError(`invalid_object\nObject name must be a string with no spaces.\n              \nInvalid value: \"${val}\"\n           `)  \n        }\n      }\n      lastToken = val\n      index += 1\n    })\n  })\n\n  // if we made it here continue exec\n  return sections\n}\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser"
    },
    {
      "id": "113",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser/_parse-section.js",
      "source": "(function (exports, require, module, __filename, __dirname) { module.exports = function visit(section) {\n  var copy = section.slice(0)\n  var name = copy.shift() // remove first el\n  var rtrn = {}\n  rtrn[name] = copy\n  return parseMembers(rtrn)\n}\n\nfunction bool(s) {\n  if (s === 'true') return true\n  if (s === 'false') return false \n  return s\n}\n\nfunction parseMembers(rtrn) {\n  \n  var num = s=> isNaN(s)? s : +s\n  var name = Object.keys(rtrn)[0]\n  var members = rtrn[name]\n  var finals = []\n  var index = 0\n  var lastObj = 0\n\n  members.forEach(member=> {\n    \n    // this line has no spaces\n    var isSingle = !/ /g.test(member)\n\n    // maps start with no spaces and have indented tuple members\n    var isMap = (function lookAhead(all) {\n      var curIndex = all.indexOf(member)\n      var nextMember = all[curIndex + 1]\n      return isSingle && nextMember && nextMember.startsWith('  ')\n    })(members)\n\n    var isMapMember = member.startsWith('  ')\n\n    var isVector = !isMapMember && !isSingle && Array.isArray(member.split(' '))\n\n    if (isMap) {\n      var anon = {}\n      anon[member] = {}\n      lastObj = index\n      finals.push(anon)\n      index += 1\n    }\n    else if (isMapMember) {\n      var tupleMember = member.trim().split(' ').map(num).map(bool)\n      var idx = lastObj\n      var name = Object.keys(finals[idx])[0]\n      var prop = tupleMember.shift()\n      finals[idx][name][prop] = tupleMember.length === 1? tupleMember[0] : (tupleMember.length === 0? false : tupleMember)\n    }\n    else if (isVector) {\n      finals.push(member.split(' ').map(num).map(bool))\n      index += 1\n    }\n    else if (isSingle) {\n      finals.push(isNaN(member)? bool(member) : +member)  \n      index += 1\n    }\n    else {\n      console.log('WARN: ignored unknown member ', member)\n    }\n  })\n\n  var reconstruct = {}\n  reconstruct[name] = finals\n  return reconstruct\n}\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser"
    },
    {
      "id": "114",
      "url": "console.js",
      "source": "(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\n\nfunction Console(stdout, stderr, ignoreErrors = true) {\n  if (!(this instanceof Console)) {\n    return new Console(stdout, stderr, ignoreErrors);\n  }\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new TypeError('Console expects a writable stream instance');\n  }\n  if (!stderr) {\n    stderr = stdout;\n  } else if (typeof stderr.write !== 'function') {\n    throw new TypeError('Console expects writable stream instances');\n  }\n\n  var prop = {\n    writable: true,\n    enumerable: false,\n    configurable: true\n  };\n  prop.value = stdout;\n  Object.defineProperty(this, '_stdout', prop);\n  prop.value = stderr;\n  Object.defineProperty(this, '_stderr', prop);\n  prop.value = ignoreErrors;\n  Object.defineProperty(this, '_ignoreErrors', prop);\n  prop.value = new Map();\n  Object.defineProperty(this, '_times', prop);\n  prop.value = createWriteErrorHandler(stdout);\n  Object.defineProperty(this, '_stdoutErrorHandler', prop);\n  prop.value = createWriteErrorHandler(stderr);\n  Object.defineProperty(this, '_stderrErrorHandler', prop);\n\n  // bind the prototype functions to this Console instance\n  var keys = Object.keys(Console.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var k = keys[v];\n    this[k] = this[k].bind(this);\n  }\n}\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(stream) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    if (err && !stream._writableState.errorEmitted) {\n      // If there was an error, it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception, but since the handler is\n      // removed after the event, non-console.* writes wont be affected.\n      stream.once('error', noop);\n    }\n  };\n}\n\nfunction write(ignoreErrors, stream, string, errorhandler) {\n  if (!ignoreErrors) return stream.write(string);\n\n  // There may be an error occurring synchronously (e.g. for files or TTYs\n  // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so\n  // handle both situations.\n  try {\n    // Add and later remove a noop error handler to catch synchronous errors.\n    stream.once('error', noop);\n\n    stream.write(string, errorhandler);\n  } catch (e) {\n    // Sorry, theres no proper way to pass along the error here.\n  } finally {\n    stream.removeListener('error', noop);\n  }\n}\n\n\n// As of v8 5.0.71.32, the combination of rest param, template string\n// and .apply(null, args) benchmarks consistently faster than using\n// the spread operator when calling util.format.\nConsole.prototype.log = function log(...args) {\n  write(this._ignoreErrors,\n        this._stdout,\n        `${util.format.apply(null, args)}\\n`,\n        this._stdoutErrorHandler);\n};\n\n\nConsole.prototype.info = Console.prototype.log;\n\n\nConsole.prototype.warn = function warn(...args) {\n  write(this._ignoreErrors,\n        this._stderr,\n        `${util.format.apply(null, args)}\\n`,\n        this._stderrErrorHandler);\n};\n\n\nConsole.prototype.error = Console.prototype.warn;\n\n\nConsole.prototype.dir = function dir(object, options) {\n  options = Object.assign({customInspect: false}, options);\n  write(this._ignoreErrors,\n        this._stdout,\n        `${util.inspect(object, options)}\\n`,\n        this._stdoutErrorHandler);\n};\n\n\nConsole.prototype.time = function time(label) {\n  this._times.set(label, process.hrtime());\n};\n\n\nConsole.prototype.timeEnd = function timeEnd(label) {\n  const time = this._times.get(label);\n  if (!time) {\n    process.emitWarning(`No such label '${label}' for console.timeEnd()`);\n    return;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n  this.log('%s: %sms', label, ms.toFixed(3));\n  this._times.delete(label);\n};\n\n\nConsole.prototype.trace = function trace(...args) {\n  // TODO probably can to do this better with V8's debug object once that is\n  // exposed.\n  var err = new Error();\n  err.name = 'Trace';\n  err.message = util.format.apply(null, args);\n  Error.captureStackTrace(err, trace);\n  this.error(err.stack);\n};\n\n\nConsole.prototype.assert = function assert(expression, ...args) {\n  if (!expression) {\n    require('assert').ok(false, util.format.apply(null, args));\n  }\n};\n\n\nmodule.exports = new Console(process.stdout, process.stderr);\nmodule.exports.Console = Console;\n\nfunction noop() {}\n\n});",
      "pkgUrl": "(system)"
    },
    {
      "id": "87",
      "url": "net.js",
      "source": "(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nconst timers = require('timers');\nconst util = require('util');\nconst internalUtil = require('internal/util');\nconst internalNet = require('internal/net');\nconst assert = require('assert');\nconst cares = process.binding('cares_wrap');\nconst uv = process.binding('uv');\n\nconst Buffer = require('buffer').Buffer;\nconst TTYWrap = process.binding('tty_wrap');\nconst TCP = process.binding('tcp_wrap').TCP;\nconst Pipe = process.binding('pipe_wrap').Pipe;\nconst TCPConnectWrap = process.binding('tcp_wrap').TCPConnectWrap;\nconst PipeConnectWrap = process.binding('pipe_wrap').PipeConnectWrap;\nconst ShutdownWrap = process.binding('stream_wrap').ShutdownWrap;\nconst WriteWrap = process.binding('stream_wrap').WriteWrap;\nconst async_id_symbol = process.binding('async_wrap').async_id_symbol;\nconst { newUid, setInitTriggerId } = require('async_hooks');\nconst nextTick = require('internal/process/next_tick').nextTick;\nconst errors = require('internal/errors');\n\nvar cluster;\nvar dns;\n\nconst errnoException = util._errnoException;\nconst exceptionWithHostPort = util._exceptionWithHostPort;\nconst isLegalPort = internalNet.isLegalPort;\nconst normalizedArgsSymbol = internalNet.normalizedArgsSymbol;\n\nfunction noop() {}\n\nfunction createHandle(fd) {\n  var type = TTYWrap.guessHandleType(fd);\n  if (type === 'PIPE') return new Pipe();\n  if (type === 'TCP') return new TCP();\n  throw new TypeError('Unsupported fd type: ' + type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n      newUid() : handle.getAsyncId();\n}\n\n\nconst debug = util.debuglog('net');\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\nfunction createServer(options, connectionListener) {\n  return new Server(options, connectionListener);\n}\n\n\n// Target API:\n//\n// var s = net.connect({port: 80, host: 'google.com'}, function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options, [cb])\n// connect(port, [host], [cb])\n// connect(path, [cb]);\n//\nfunction connect() {\n  var args = new Array(arguments.length);\n  for (var i = 0; i < arguments.length; i++)\n    args[i] = arguments[i];\n  // TODO(joyeecheung): use destructuring when V8 is fast enough\n  var normalized = normalizeArgs(args);\n  var options = normalized[0];\n  debug('createConnection', normalized);\n  var socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return Socket.prototype.connect.call(socket, normalized);\n}\n\n\n// Returns an array [options, cb], where options is an object,\n// cb is either a funciton or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of paramters:\n//   (options[...][, cb])\n//   (path[...][, cb])\n//   ([port][, host][...][, cb])\n// For Socket.prototype.connect(), the [...] part is ignored\n// For Server.prototype.listen(), the [...] part is [, backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  var arr;\n\n  if (args.length === 0) {\n    arr = [{}, null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  var options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][, cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][, cb])\n    options.path = arg0;\n  } else {\n    // ([port][, host][...][, cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  var cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options, null];\n  else\n    arr = [options, cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// called when creating new Socket, or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._bytesDispatched = 0;\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle.owner = self;\n    self._handle.onread = onread;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    // If handle doesn't support writev - neither do we\n    if (!self._handle.writev)\n      self._writev = null;\n  }\n}\n\n\nconst BYTES_READ = Symbol('bytesRead');\n\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle, that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this._handle = null;\n  this._parent = null;\n  this._host = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else if (options === undefined)\n    options = {};\n\n  stream.Duplex.call(this, options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    this._handle = createHandle(options.fd);\n    this._handle.open(options.fd);\n    this[async_id_symbol] = this._handle.getAsyncId();\n    // options.fd can be string (since it is user-defined),\n    // so changing this to === would be semver-major\n    // See: https://github.com/nodejs/node/pull/11513\n    // eslint-disable-next-line eqeqeq\n    if ((options.fd == 1 || options.fd == 2) &&\n        (this._handle instanceof Pipe) &&\n        process.platform === 'win32') {\n      // Make stdout and stderr blocking on Windows\n      var err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err, 'setBlocking');\n    }\n    this.readable = options.readable !== false;\n    this.writable = options.writable !== false;\n  } else {\n    // these will be set once there is a connection\n    this.readable = this.writable = false;\n  }\n\n  // shut down the socket when we're finished with it.\n  this.on('finish', onSocketFinish);\n  this.on('_socketEnd', onSocketEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // handle strings directly\n  this._writableState.decodeStrings = false;\n\n  // default to *not* allowing half open sockets\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\n\n  // if we have a handle, then start the flow of data into the\n  // buffer.  if not, then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this._readableState.flowing = false;\n    } else {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[BYTES_READ] = 0;\n}\nutil.inherits(Socket, stream.Duplex);\n\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (var s = this; s !== null; s = s._parent)\n    timers._unrefActive(s);\n};\n\n// the user has called .end(), and all the bytes have been\n// sent out to the other side.\nfunction onSocketFinish() {\n  // If still connecting - defer handling 'finish' until 'connect' will happen\n  if (this.connecting) {\n    debug('osF: not yet connected');\n    return this.once('connect', onSocketFinish);\n  }\n\n  debug('onSocketFinish');\n  if (!this.readable || this._readableState.ended) {\n    debug('oSF: ended, destroy', this._readableState);\n    return this.destroy();\n  }\n\n  debug('oSF: not ended, call shutdown()');\n\n  // otherwise, just shutdown, or destroy() if not possible\n  if (!this._handle || !this._handle.shutdown)\n    return this.destroy();\n\n  var req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  // node::ShutdownWrap isn't instantiated and attached to the JS instance of\n  // ShutdownWrap above until shutdown() is called. So don't set the init\n  // trigger id until now.\n  setInitTriggerId(this[async_id_symbol]);\n  var err = this._handle.shutdown(req);\n\n  if (err)\n    return this.destroy(errnoException(err, 'shutdown'));\n}\n\n\nfunction afterShutdown(status, handle, req) {\n  var self = handle.owner;\n\n  debug('afterShutdown destroyed=%j', self.destroyed,\n        self._readableState);\n\n  // callback may come after call to destroy.\n  if (self.destroyed)\n    return;\n\n  if (self._readableState.ended) {\n    debug('readableState ended, destroying');\n    self.destroy();\n  } else {\n    self.once('_socketEnd', self.destroy);\n  }\n}\n\n// the EOF has been received, and no more bytes are coming.\n// if the writable side has ended already, then clean everything\n// up.\nfunction onSocketEnd() {\n  // XXX Should not have to do as much crap in this function.\n  // ended should already be true, since this is called *after*\n  // the EOF errno and onread has eof'ed\n  debug('onSocketEnd', this._readableState);\n  this._readableState.ended = true;\n  if (this._readableState.endEmitted) {\n    this.readable = false;\n    maybeDestroy(this);\n  } else {\n    this.once('end', function end() {\n      this.readable = false;\n      maybeDestroy(this);\n    });\n    this.read(0);\n  }\n\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    this.destroySoon();\n  }\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague, and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk, encoding, cb) {\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  var er = new Error('This socket has been ended by the other party');\n  er.code = 'EPIPE';\n  // TODO: defer error events consistently everywhere, not just the cb\n  this.emit('error', er);\n  if (typeof cb === 'function') {\n    nextTick(this[async_id_symbol], cb, er);\n  }\n}\n\nSocket.prototype.read = function(n) {\n  if (n === 0)\n    return stream.Readable.prototype.read.call(this, n);\n\n  this.read = stream.Readable.prototype.read;\n  this._consuming = true;\n  return this.read(n);\n};\n\n\n// FIXME(joyeecheung): this method is neither documented nor tested\nSocket.prototype.listen = function() {\n  debug('socket.listen');\n  this.on('connection', arguments[0]);\n  listenInCluster(this, null, null, null);\n};\n\n\nSocket.prototype.setTimeout = function(msecs, callback) {\n  if (msecs === 0) {\n    timers.unenroll(this);\n    if (callback) {\n      this.removeListener('timeout', callback);\n    }\n  } else {\n    timers.enroll(this, msecs);\n    timers._unrefActive(this);\n    if (callback) {\n      this.once('timeout', callback);\n    }\n  }\n  return this;\n};\n\n\nSocket.prototype._onTimeout = function() {\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  if (!this._handle) {\n    this.once('connect',\n              enable ? this.setNoDelay : () => this.setNoDelay(enable));\n    return this;\n  }\n\n  // backwards compatibility: assume true when `enable` is omitted\n  if (this._handle.setNoDelay)\n    this._handle.setNoDelay(enable === undefined ? true : !!enable);\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(setting, msecs) {\n  if (!this._handle) {\n    this.once('connect', () => this.setKeepAlive(setting, msecs));\n    return this;\n  }\n\n  if (this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObject.defineProperty(Socket.prototype, '_connecting', {\n  get: function() {\n    return this.connecting;\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'readyState', {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    } else {\n      return 'closed';\n    }\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'bufferSize', {\n  get: function() {\n    if (this._handle) {\n      return this._handle.writeQueueSize + this._writableState.length;\n    }\n  }\n});\n\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect', () => this._read(n));\n  } else if (!this._handle.reading) {\n    // not already reading, start the flow\n    debug('Socket._read readStart');\n    this._handle.reading = true;\n    var err = this._handle.readStart();\n    if (err)\n      this.destroy(errnoException(err, 'read'));\n  }\n};\n\n\nSocket.prototype.end = function(data, encoding) {\n  stream.Duplex.prototype.end.call(this, data, encoding);\n  this.writable = false;\n  DTRACE_NET_STREAM_END(this);\n  ;\n\n  // just in case we're waiting for an EOF.\n  if (this.readable && !this._readableState.endEmitted)\n    this.read(0);\n  else\n    maybeDestroy(this);\n\n  return this;\n};\n\n\n// Call whenever we set writable=false or readable=false\nfunction maybeDestroy(socket) {\n  if (!socket.readable &&\n      !socket.writable &&\n      !socket.destroyed &&\n      !socket.connecting &&\n      !socket._writableState.length) {\n    socket.destroy();\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this._writableState.finished)\n    this.destroy();\n  else\n    this.once('finish', this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception, cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  this.readable = this.writable = false;\n\n  for (var s = this; s !== null; s = s._parent)\n    timers.unenroll(s);\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    var isException = exception ? true : false;\n    // `bytesRead` should be accessible after `.destroy()`\n    this[BYTES_READ] = this._handle.bytesRead;\n\n    this._handle.close(() => {\n      debug('emit close');\n      this.emit('close', isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n  }\n\n  cb(exception);\n\n  if (this._server) {\n    ;\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\n\n// This function is called whenever the handle gets a\n// buffer, or when there's an error reading.\nfunction onread(nread, buffer) {\n  var handle = this;\n  var self = handle.owner;\n  assert(handle === self._handle, 'handle != self._handle');\n\n  self._unrefTimer();\n\n  debug('onread', nread);\n\n  if (nread > 0) {\n    debug('got data');\n\n    // read success.\n    // In theory (and in practice) calling readStop right now\n    // will prevent this from being called again until _read() gets\n    // called again.\n\n    // Optimization: emit the original buffer with end points\n    var ret = self.push(buffer);\n\n    if (handle.reading && !ret) {\n      handle.reading = false;\n      debug('readStop');\n      var err = handle.readStop();\n      if (err)\n        self.destroy(errnoException(err, 'read'));\n    }\n    return;\n  }\n\n  // if we didn't get any bytes, that doesn't necessarily mean EOF.\n  // wait for the next one.\n  if (nread === 0) {\n    debug('not any data, keep waiting');\n    return;\n  }\n\n  // Error, possibly EOF.\n  if (nread !== uv.UV_EOF) {\n    return self.destroy(errnoException(nread, 'read'));\n  }\n\n  debug('EOF');\n\n  // push a null to signal the end of data.\n  // Do it before `maybeDestroy` for correct order of events:\n  // `end` -> `close`\n  self.push(null);\n\n  if (self._readableState.length === 0) {\n    self.readable = false;\n    maybeDestroy(self);\n  }\n\n  // internal end event so that we know that the actual socket\n  // is no longer readable, and we can start the shutdown\n  // procedure. No need to wait for all the data to be consumed.\n  self.emit('_socketEnd');\n}\n\n\nSocket.prototype._getpeername = function() {\n  if (!this._peername) {\n    if (!this._handle || !this._handle.getpeername) {\n      return {};\n    }\n    var out = {};\n    var err = this._handle.getpeername(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._peername = out;\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name, callback) {\n  Object.defineProperty(Socket.prototype, name, {\n    configurable: false,\n    enumerable: true,\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead', function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[BYTES_READ];\n});\n\nprotoGetter('remoteAddress', function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily', function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort', function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  }\n  if (!this._sockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._sockname = out;\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress', function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort', function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype.write = function(chunk, encoding, cb) {\n  if (typeof chunk !== 'string' && !(chunk instanceof Buffer)) {\n    throw new TypeError(\n      'Invalid data, chunk must be a string or buffer, not ' + typeof chunk);\n  }\n  return stream.Duplex.prototype.write.apply(this, arguments);\n};\n\n\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\n  // If we are still connecting, then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect', function connect() {\n      this._writeGeneric(writev, data, encoding, cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  this._unrefTimer();\n\n  if (!this._handle) {\n    this.destroy(new Error('This socket is closed'), cb);\n    return false;\n  }\n\n  var req = new WriteWrap();\n  req.handle = this._handle;\n  req.oncomplete = afterWrite;\n  req.async = false;\n  var err;\n\n  if (writev) {\n    var allBuffers = data.allBuffers;\n    var chunks;\n    var i;\n    if (allBuffers) {\n      chunks = data;\n      for (i = 0; i < data.length; i++)\n        data[i] = data[i].chunk;\n    } else {\n      chunks = new Array(data.length << 1);\n      for (i = 0; i < data.length; i++) {\n        var entry = data[i];\n        chunks[i * 2] = entry.chunk;\n        chunks[i * 2 + 1] = entry.encoding;\n      }\n    }\n    err = this._handle.writev(req, chunks, allBuffers);\n\n    // Retain chunks\n    if (err === 0) req._chunks = chunks;\n  } else {\n    var enc;\n    if (data instanceof Buffer) {\n      enc = 'buffer';\n    } else {\n      enc = encoding;\n    }\n    err = createWriteReq(req, this._handle, data, enc);\n  }\n\n  if (err)\n    return this.destroy(errnoException(err, 'write', req.error), cb);\n\n  this._bytesDispatched += req.bytes;\n\n  // If it was entirely flushed, we can write some more right now.\n  // However, if more is left in the queue, then wait until that clears.\n  if (req.async && this._handle.writeQueueSize !== 0)\n    req.cb = cb;\n  else\n    cb();\n};\n\n\nSocket.prototype._writev = function(chunks, cb) {\n  this._writeGeneric(true, chunks, '', cb);\n};\n\n\nSocket.prototype._write = function(data, encoding, cb) {\n  this._writeGeneric(false, data, encoding, cb);\n};\n\nfunction createWriteReq(req, handle, data, encoding) {\n  switch (encoding) {\n    case 'latin1':\n    case 'binary':\n      return handle.writeLatin1String(req, data);\n\n    case 'buffer':\n      return handle.writeBuffer(req, data);\n\n    case 'utf8':\n    case 'utf-8':\n      return handle.writeUtf8String(req, data);\n\n    case 'ascii':\n      return handle.writeAsciiString(req, data);\n\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return handle.writeUcs2String(req, data);\n\n    default:\n      return handle.writeBuffer(req, Buffer.from(data, encoding));\n  }\n}\n\n\nprotoGetter('bytesWritten', function bytesWritten() {\n  var bytes = this._bytesDispatched;\n  const state = this._writableState;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n\n  if (!state)\n    return undefined;\n\n  state.getBuffer().forEach(function(el) {\n    if (el.chunk instanceof Buffer)\n      bytes += el.chunk.length;\n    else\n      bytes += Buffer.byteLength(el.chunk, el.encoding);\n  });\n\n  if (data) {\n    if (data instanceof Buffer)\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data, encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction afterWrite(status, handle, req, err) {\n  var self = handle.owner;\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite', status);\n\n  // callback may come after call to destroy.\n  if (self.destroyed) {\n    debug('afterWrite destroyed');\n    return;\n  }\n\n  if (status < 0) {\n    var ex = errnoException(status, 'write', req.error);\n    debug('write failure', ex);\n    self.destroy(ex, req.cb);\n    return;\n  }\n\n  self._unrefTimer();\n\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite call cb');\n\n  if (req.cb)\n    req.cb.call(self);\n}\n\n\nfunction internalConnect(\n  self, address, port, addressType, localAddress, localPort) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert.ok(self.connecting);\n\n  var err;\n\n  if (localAddress || localPort) {\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)',\n          localAddress, localPort, addressType);\n\n    if (addressType === 4) {\n      localAddress = localAddress || '0.0.0.0';\n      err = self._handle.bind(localAddress, localPort);\n    } else if (addressType === 6) {\n      localAddress = localAddress || '::';\n      err = self._handle.bind6(localAddress, localPort);\n    } else {\n      self.destroy(new TypeError('Invalid addressType: ' + addressType));\n      return;\n    }\n\n    if (err) {\n      const ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    // node::TCPConnectWrap isn't instantiated and attached to the JS instance\n    // of TCPConnectWrap above until connect() is called. So don't set the init\n    // trigger id until now.\n    setInitTriggerId(self[async_id_symbol]);\n    if (addressType === 4)\n      err = self._handle.connect(req, address, port);\n    else\n      err = self._handle.connect6(req, address, port);\n\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n    // node::PipeConnectWrap isn't instantiated and attached to the JS instance\n    // of PipeConnectWrap above until connect() is called. So don't set the\n    // init trigger id until now.\n    setInitTriggerId(self[async_id_symbol]);\n    err = self._handle.connect(req, address, afterConnect);\n  }\n\n  if (err) {\n    var sockname = self._getsockname();\n    var details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err, 'connect', address, port, details);\n    self.destroy(ex);\n  }\n}\n\n\nSocket.prototype.connect = function() {\n  let normalized;\n  // If passed an array, it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342, but was\n  // reverted as it had unintended side effects.\n  if (Array.isArray(arguments[0]) && arguments[0][normalizedArgsSymbol]) {\n    normalized = arguments[0];\n  } else {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++)\n      args[i] = arguments[i];\n    // TODO(joyeecheung): use destructuring when V8 is fast enough\n    normalized = normalizeArgs(args);\n  }\n  var options = normalized[0];\n  var cb = normalized[1];\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._undestroy();\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const path = options.path;\n  var pipe = !!path;\n  debug('pipe', pipe, path);\n\n  if (!this._handle) {\n    this._handle = pipe ? new Pipe() : new TCP();\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect', cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n  this.writable = true;\n\n  if (pipe) {\n    if (typeof path !== 'string') {\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n        'options.path',\n        'string',\n        path);\n    }\n    internalConnect(this, path);\n  } else {\n    lookupAndConnect(this, options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self, options) {\n  const dns = lazyDns();\n  var host = options.host || 'localhost';\n  var port = options.port;\n  var localAddress = options.localAddress;\n  var localPort = options.localPort;\n\n  if (localAddress && !cares.isIP(localAddress))\n    throw new TypeError('\"localAddress\" option must be a valid IP: ' +\n                        localAddress);\n\n  if (localPort && typeof localPort !== 'number')\n    throw new TypeError('\"localPort\" option should be a number: ' + localPort);\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string')\n      throw new TypeError('\"port\" option should be a number or string: ' +\n                          port);\n    if (!isLegalPort(port))\n      throw new RangeError('\"port\" option should be >= 0 and < 65536: ' + port);\n  }\n  port |= 0;\n\n  // If host is an IP, skip performing a lookup\n  var addressType = cares.isIP(host);\n  if (addressType) {\n    nextTick(self[async_id_symbol], function() {\n      if (self.connecting)\n        internalConnect(self, host, port, addressType, localAddress, localPort);\n    });\n    return;\n  }\n\n  if (options.lookup && typeof options.lookup !== 'function')\n    throw new TypeError('\"lookup\" option should be a function');\n\n  var dnsopts = {\n    family: options.family,\n    hints: options.hints || 0\n  };\n\n  if (dnsopts.family !== 4 && dnsopts.family !== 6 && dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host', host);\n  debug('connect: dns options', dnsopts);\n  self._host = host;\n  var lookup = options.lookup || dns.lookup;\n  setInitTriggerId(self[async_id_symbol]);\n  lookup(host, dnsopts, function emitLookup(err, ip, addressType) {\n    self.emit('lookup', err, ip, addressType, host);\n\n    // It's possible we were destroyed while looking this up.\n    // XXX it would be great if we could cancel the promise returned by\n    // the look up.\n    if (!self.connecting) return;\n\n    if (err) {\n      // net.createConnection() creates a net.Socket object and\n      // immediately calls net.Socket.connect() on it (that's us).\n      // There are no event listeners registered yet so defer the\n      // error event to the next tick.\n      err.host = options.host;\n      err.port = options.port;\n      err.message = err.message + ' ' + options.host + ':' + options.port;\n      process.nextTick(connectErrorNT, self, err);\n    } else {\n      self._unrefTimer();\n      internalConnect(self,\n                      ip,\n                      port,\n                      addressType,\n                      localAddress,\n                      localPort);\n    }\n  });\n}\n\n\nfunction connectErrorNT(self, err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect', this.ref);\n    return this;\n  }\n\n  this._handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect', this.unref);\n    return this;\n  }\n\n  this._handle.unref();\n\n  return this;\n};\n\n\nfunction afterConnect(status, handle, req, readable, writable) {\n  var self = handle.owner;\n\n  // callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  // Update handle if it was wrapped\n  // TODO(indutny): assert that the handle is actually an ancestor of old one\n  handle = self._handle;\n\n  debug('afterConnect');\n\n  assert.ok(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    self.readable = readable;\n    self.writable = writable;\n    self._unrefTimer();\n\n    self.emit('connect');\n\n    // start the first read, or get an immediate EOF.\n    // this doesn't actually consume any bytes, because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n\n  } else {\n    self.connecting = false;\n    var details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    var ex = exceptionWithHostPort(status,\n                                   'connect',\n                                   req.address,\n                                   req.port,\n                                   details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\n\nfunction Server(options, connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options, connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection', connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = options || {};\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection', connectionListener);\n    }\n  } else {\n    throw new TypeError('options must be an object');\n  }\n\n  this._connections = 0;\n\n  Object.defineProperty(this, 'connections', {\n    get: internalUtil.deprecate(() => {\n\n      if (this._usingSlaves) {\n        return null;\n      }\n      return this._connections;\n    }, 'Server.connections property is deprecated. ' +\n       'Use Server.getConnections method instead.', 'DEP0020'),\n    set: internalUtil.deprecate((val) => (this._connections = val),\n                                'Server.connections property is deprecated.',\n                                'DEP0020'),\n    configurable: true, enumerable: false\n  });\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingSlaves = false;\n  this._slaves = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n}\nutil.inherits(Server, EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created, or error code if it can't\nfunction createServerHandle(address, port, addressType, fd) {\n  var err = 0;\n  // assign handle in listen, and clean up if bind or listen fails\n  var handle;\n\n  var isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:', fd, e.message);\n      return uv.UV_EINVAL;\n    }\n    handle.open(fd);\n    handle.readable = true;\n    handle.writable = true;\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe();\n    if (process.platform === 'win32') {\n      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!isNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP();\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to', address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6('::', port);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle('0.0.0.0', port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address, port);\n    } else {\n      err = handle.bind(address, port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address, port, addressType, backlog, fd) {\n  debug('setupListenHandle', address, port, addressType, backlog, fd);\n\n  // If there is not yet a handle, we need to create one and bind.\n  // In the case of a server sent via IPC, we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    var rval = null;\n\n    // Try to bind to the unspecified IPv6 address, see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle('::', port, 6, fd);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = '0.0.0.0';\n        addressType = 4;\n      } else {\n        address = '::';\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address, port, addressType, fd);\n\n    if (typeof rval === 'number') {\n      var error = exceptionWithHostPort(rval, 'listen', address, port);\n      process.nextTick(emitErrorNT, this, error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle.owner = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  var err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    var ex = exceptionWithHostPort(err, 'listen', address, port);\n    this._handle.close();\n    this._handle = null;\n    nextTick(this[async_id_symbol], emitErrorNT, this, ex);\n    return;\n  }\n\n  // generate connection key, this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  nextTick(this[async_id_symbol], emitListeningNT, this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\n\nfunction emitListeningNT(self) {\n  // ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction lazyDns() {\n  if (dns === undefined)\n    dns = require('dns');\n  return dns;\n}\n\n\nfunction listenInCluster(server, address, port, addressType,\n                         backlog, fd, exclusive) {\n  exclusive = !!exclusive;\n\n  if (!cluster) cluster = require('cluster');\n\n  if (cluster.isMaster || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd);\n    return;\n  }\n\n  const serverQuery = {\n    address: address,\n    port: port,\n    addressType: addressType,\n    fd: fd,\n    flags: 0\n  };\n\n  // Get the master's server handle, and listen on it\n  cluster._getServer(server, serverQuery, listenOnMasterHandle);\n\n  function listenOnMasterHandle(err, handle) {\n    // EADDRINUSE may not be reported until we call listen(). To complicate\n    // matters, a failed bind() followed by listen() will implicitly bind to\n    // a random port. Ergo, check that the socket is bound to the expected\n    // port before calling listen().\n    //\n    // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\n    // getsockname() method. Non-issue for now, the cluster module doesn't\n    // really support pipes anyway.\n    if (err === 0 && port > 0 && handle.getsockname) {\n      var out = {};\n      err = handle.getsockname(out);\n      if (err === 0 && port !== out.port)\n        err = uv.UV_EADDRINUSE;\n    }\n\n    if (err) {\n      var ex = exceptionWithHostPort(err, 'bind', address, port);\n      return server.emit('error', ex);\n    }\n\n    // Reuse master's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd);\n  }\n}\n\n\nServer.prototype.listen = function() {\n  var args = new Array(arguments.length);\n  for (var i = 0; i < arguments.length; i++)\n    args[i] = arguments[i];\n  // TODO(joyeecheung): use destructuring when V8 is fast enough\n  var normalized = normalizeArgs(args);\n  var options = normalized[0];\n  var cb = normalized[1];\n\n  var hasCallback = (cb !== null);\n  if (hasCallback) {\n    this.once('listening', cb);\n  }\n  var backlogFromArgs =\n    // (handle, backlog) or (path, backlog) or (port, backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port, host, backlog)\n\n  options = options._handle || options.handle || options;\n  // (handle[, backlog][, cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this, null, -1, -1, backlogFromArgs);\n    return this;\n  }\n  // (handle[, backlog][, cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this, null, null, null, backlogFromArgs, options.fd);\n    return this;\n  }\n\n  // ([port][, host][, backlog][, cb]) where port is omitted,\n  // that is, listen() or listen(cb),\n  // or (options[, cb]) where options.port is explicitly set as undefined,\n  // bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n    (typeof options.port === 'undefined' && 'port' in options)) {\n    options.port = 0;\n  }\n  // ([port][, host][, backlog][, cb]) where port is specified\n  // or (options[, cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  var backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    if (!isLegalPort(options.port)) {\n      throw new RangeError('\"port\" argument must be >= 0 and < 65536');\n    }\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this, options.port | 0, options.host, backlog,\n                      options.exclusive);\n    } else { // Undefined host, listens on unspecified address\n      // Default addressType 4 will be used to search for master server\n      listenInCluster(this, null, options.port | 0, 4,\n                      backlog, undefined, options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[, backlog][, cb]) or (options[, cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    var pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this, pipeName, -1, -1,\n                    backlog, undefined, options.exclusive);\n    return this;\n  }\n\n  throw new Error('Invalid listen argument: ' + util.inspect(options));\n};\n\nfunction lookupAndListen(self, port, address, backlog, exclusive) {\n  const dns = lazyDns();\n  dns.lookup(address, function doListen(err, ip, addressType) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self, ip, port, addressType,\n                      backlog, undefined, exclusive);\n    }\n  });\n}\n\nObject.defineProperty(Server.prototype, 'listening', {\n  get: function() {\n    return !!this._handle;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err, 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  } else {\n    return null;\n  }\n};\n\nfunction onconnection(err, clientHandle) {\n  var handle = this;\n  var self = handle.owner;\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  var socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect\n  });\n  socket.readable = socket.writable = true;\n\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  ;\n  ;\n  self.emit('connection', socket);\n}\n\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err, connections) {\n    nextTick(self[async_id_symbol], cb, err, connections);\n  }\n\n  if (!this._usingSlaves) {\n    return end(null, this._connections);\n  }\n\n  // Poll slaves\n  var left = this._slaves.length;\n  var total = this._connections;\n\n  function oncount(err, count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null, total);\n  }\n\n  for (var n = 0; n < this._slaves.length; n++) {\n    this._slaves[n].getConnections(oncount);\n  }\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close', function close() {\n        cb(new Error('Not running'));\n      });\n    } else {\n      this.once('close', cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingSlaves) {\n    var left = this._slaves.length;\n    const onSlaveClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that, even if all sockets will be closed\n    // during polling of slaves, `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll slaves\n    for (var n = 0; n < this._slaves.length; n++)\n      this._slaves[n].close(onSlaveClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d',\n          !!this._handle, this._connections);\n    return;\n  }\n\n  const asyncId = this._handle ? this[async_id_symbol] : null;\n  nextTick(asyncId, emitCloseNT, this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype.listenFD = internalUtil.deprecate(function(fd, type) {\n  return this.listen({ fd: fd });\n}, 'Server.listenFD is deprecated. Use Server.listen({fd: <number>}) instead.',\n                                                   'DEP0021');\n\nServer.prototype._setupSlave = function(socketList) {\n  this._usingSlaves = true;\n  this._slaves.push(socketList);\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nvar _setSimultaneousAccepts;\n\nif (process.platform === 'win32') {\n  var simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function(handle) {};\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle,\n  _normalizeArgs: normalizeArgs,\n  _setSimultaneousAccepts,\n  connect,\n  createConnection: connect,\n  createServer,\n  isIP: cares.isIP,\n  isIPv4: cares.isIPv4,\n  isIPv6: cares.isIPv6,\n  Server,\n  Socket,\n  Stream: Socket, // Legacy naming\n};\n\n});",
      "pkgUrl": "(system)"
    },
    {
      "id": "51",
      "url": "_stream_writable.js",
      "source": "(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst util = require('util');\nconst internalUtil = require('internal/util');\nconst Stream = require('stream');\nconst Buffer = require('buffer').Buffer;\nconst destroyImpl = require('internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Stream.Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = onwrite.bind(undefined, stream);\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  var corkReq = { next: null, entry: null, finish: undefined };\n  corkReq.finish = onCorkedFinish.bind(undefined, corkReq, this);\n  this.corkedRequestsFree = corkReq;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\nObject.defineProperty(WritableState.prototype, 'buffer', {\n  get: internalUtil.deprecate(function() {\n    return this.getBuffer();\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\n     'instead.', 'DEP0003')\n});\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance) {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function(object) {\n      if (realHasInstance.call(this, object))\n        return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!(realHasInstance.call(Writable, this)) &&\n      !(this instanceof Stream.Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' &&\n             chunk !== undefined &&\n             !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    process.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = Stream._isUint8Array(chunk) && !state.objectMode;\n\n  if (isBuf && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n    chunk = Stream._uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf)\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = nop;\n\n  if (state.ended)\n    writeAfterEnd(this, cb);\n  else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.bufferedRequest)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = encoding.toLowerCase();\n  if (!Buffer.isEncoding(encoding))\n    throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk,\n      encoding,\n      isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf)\n        allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      var corkReq = { next: null, entry: null, finish: undefined };\n      corkReq.finish = onCorkedFinish.bind(undefined, corkReq, state);\n      state.corkedRequestsFree = corkReq;\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null)\n      state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined)\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.bufferedRequest === null &&\n          !state.finished &&\n          !state.writing);\n}\nfunction callFinal(stream, state) {\n  stream._final((err) => {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err, cb) {\n  this.end();\n  cb(err);\n};\n\n});",
      "pkgUrl": "(system)"
    },
    {
      "id": "111",
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/test/fixtures/a-b.js",
      "source": "(function (exports, require, module, __filename, __dirname) { /**\n * removes # comments and trims leading/trailing whitespace\n */\nmodule.exports = function removeComments(text) {\n  return text.trim().replace(/\\#.*/g, '').trim()\n}\n\n});",
      "pkgUrl": "/Users/pmuellr/Projects/moar-profile-viewer"
    },
    {
      "id": "116",
      "url": "",
      "pkgUrl": "(system)"
    }
  ],
  "pkgs": [
    {
      "url": "(system)",
      "name": "(system)"
    },
    {
      "url": "(unknown)",
      "name": "(unknown)"
    },
    {
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/shelljs",
      "name": "shelljs",
      "version": "0.7.8",
      "description": "Portable Unix shell commands for Node.js",
      "homepage": "http://github.com/shelljs/shelljs",
      "dependencies": {
        "prod": {
          "glob": "^7.0.0",
          "interpret": "^1.0.0",
          "rechoir": "^0.6.2"
        },
        "dev": {
          "ava": "^0.16.0",
          "codecov": "^1.0.1",
          "coffee-script": "^1.10.0",
          "eslint": "^2.0.0",
          "eslint-config-airbnb-base": "^3.0.0",
          "eslint-plugin-import": "^1.11.1",
          "nyc": "^10.0.0",
          "shelljs-changelog": "^0.2.0",
          "shelljs-release": "^0.2.0",
          "shx": "^0.2.0",
          "travis-check-changes": "^0.2.0"
        },
        "optional": {}
      }
    },
    {
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/glob",
      "name": "glob",
      "version": "7.1.2",
      "description": "a little globber",
      "homepage": "https://github.com/isaacs/node-glob#readme",
      "dependencies": {
        "prod": {
          "fs.realpath": "^1.0.0",
          "inflight": "^1.0.4",
          "inherits": "2",
          "minimatch": "^3.0.4",
          "once": "^1.3.0",
          "path-is-absolute": "^1.0.0"
        },
        "dev": {
          "mkdirp": "0",
          "rimraf": "^2.2.8",
          "tap": "^7.1.2",
          "tick": "0.0.6"
        },
        "optional": {}
      }
    },
    {
      "url": "/Users/pmuellr/Projects/moar-profile-viewer/node_modules/@architect/parser",
      "name": "@architect/parser",
      "version": "1.0.5",
      "description": "function that accepts .arc text and returns a plain JavaScript Object",
      "dependencies": {
        "prod": {},
        "dev": {
          "tap-spec": "^4.1.1",
          "tape": "^4.6.3"
        },
        "optional": {}
      }
    },
    {
      "url": "/Users/pmuellr/Projects/moar-profile-viewer",
      "name": "moar-profile-viewer",
      "version": "0.0.1",
      "description": "converts cpuprofile files to call graphs",
      "homepage": "https://github.com/pmuellr/moar-profile-viewer",
      "dependencies": {
        "prod": {
          "graphviz-objects": "github:pmuellr/graphviz-objects",
          "jquery": "~3.2.1",
          "minimist": "~1.2.0"
        },
        "dev": {
          "browserify": "~14.4.0",
          "cat-source-map": "~0.1.2",
          "chalk": "~2.1.0",
          "less": "~2.7.2",
          "nodemon": "~1.11.0",
          "shelljs": "~0.7.8",
          "st": "~1.2.0",
          "standard": "~10.0.3",
          "tap-spec": "~4.1.1",
          "tape": "~4.8.0",
          "viz.js": "~1.8.0",
          "yield-callback": "~1.0.0"
        }
      }
    }
  ]
}
